{"meta":{"title":"Xinon's Blog","subtitle":"","description":"一个用于学习记录的个人博客","author":"Xinon Zhang","url":"https://xinonria.top","root":"/xinonria.github.io/"},"pages":[{"title":"","date":"2023-08-16T13:43:09.410Z","updated":"2023-08-16T13:43:09.410Z","comments":true,"path":"css/waline.css","permalink":"https://xinonria.top/css/waline.css","excerpt":"","text":":root{--waline-font-size: 1rem;--waline-white: #fff;--waline-light-grey: #999;--waline-dark-grey: #666;--waline-theme-color: #27ae60;--waline-active-color: #2ecc71;--waline-color: #444;--waline-bgcolor: #fff;--waline-bgcolor-light: #f8f8f8;--waline-bgcolor-hover: #f0f0f0;--waline-border-color: #ddd;--waline-disable-bgcolor: #f8f8f8;--waline-disable-color: #000;--waline-code-bgcolor: #282c34;--waline-bq-color: #f0f0f0;--waline-avatar-size: 3.25rem;--waline-m-avatar-size: calc(var(--waline-avatar-size) * 9 / 13);--waline-badge-color: #3498db;--waline-badge-font-size: 0.75em;--waline-info-bgcolor: #f8f8f8;--waline-info-color: #999;--waline-info-font-size: 0.625em;--waline-border: 1px solid var(--waline-border-color);--waline-avatar-radius: 50%;--waline-box-shadow: none}[data-waline]{font-size:var(--waline-font-size);text-align:start}[dir=rtl] [data-waline]{direction:rtl}[data-waline] *{box-sizing:content-box;line-height:1.75}[data-waline] p{color:var(--waline-color)}[data-waline] a{position:relative;display:inline-block;color:var(--waline-theme-color);text-decoration:none;word-break:break-word;cursor:pointer}[data-waline] a:hover{color:var(--waline-active-color)}[data-waline] img{max-width:100%;max-height:400px;border:none}[data-waline] hr{margin:.825em 0;border-style:dashed;border-color:var(--waline-bgcolor-light)}[data-waline] code,[data-waline] pre{margin:0;padding:.2em .4em;border-radius:3px;background:var(--waline-bgcolor-light);font-size:85%}[data-waline] pre{overflow:auto;padding:10px;line-height:1.45}[data-waline] pre::-webkit-scrollbar{width:6px;height:6px}[data-waline] pre::-webkit-scrollbar-track-piece:horizontal{-webkit-border-radius:6px;border-radius:6px;background:rgba(0,0,0,.1)}[data-waline] pre::-webkit-scrollbar-thumb:horizontal{width:6px;-webkit-border-radius:6px;border-radius:6px;background:var(--waline-theme-color)}[data-waline] pre code{padding:0;background:rgba(0,0,0,0);color:var(--waline-color);white-space:pre-wrap;word-break:keep-all}[data-waline] blockquote{margin:.5em 0;padding:.5em 0 .5em 1em;border-inline-start:8px solid var(--waline-bq-color);color:var(--waline-dark-grey)}[data-waline] blockquote>p{margin:0}[data-waline] ol,[data-waline] ul{margin-inline-start:1.25em;padding:0}[data-waline] input[type=checkbox],[data-waline] input[type=radio]{display:inline-block;vertical-align:middle;margin-top:-2px}.wl-btn{display:inline-block;vertical-align:middle;min-width:2.5em;margin-bottom:0;padding:.5em 1em;border:1px solid var(--waline-border-color);border-radius:.5em;background:rgba(0,0,0,0);color:var(--waline-color);font-weight:400;font-size:.75em;line-height:1.5;text-align:center;white-space:nowrap;cursor:pointer;user-select:none;transition-duration:.4s;touch-action:manipulation}.wl-btn:hover,.wl-btn:active{border-color:var(--waline-theme-color);color:var(--waline-theme-color)}.wl-btn:disabled{border-color:var(--waline-border-color);background:var(--waline-disable-bgcolor);color:var(--waline-disable-color);cursor:not-allowed}.wl-btn.primary{border-color:var(--waline-theme-color);background:var(--waline-theme-color);color:var(--waline-white)}.wl-btn.primary:hover,.wl-btn.primary:active{border-color:var(--waline-active-color);background:var(--waline-active-color);color:var(--waline-white)}.wl-btn.primary:disabled{border-color:var(--waline-border-color);background:var(--waline-disable-bgcolor);color:var(--waline-disable-color);cursor:not-allowed}.wl-loading{text-align:center}.wl-loading svg{margin:0 auto}.wl-comment{position:relative;display:flex;margin-bottom:.75em}.wl-close{position:absolute;top:-4px;inset-inline-end:-4px;padding:0;border:none;background:rgba(0,0,0,0);line-height:1;cursor:pointer}.wl-login-info{max-width:80px;margin-top:.75em;text-align:center}.wl-logout-btn{position:absolute;top:-10px;inset-inline-end:-10px;padding:3px;border:none;background:rgba(0,0,0,0);line-height:0;cursor:pointer}.wl-avatar{position:relative;width:var(--waline-avatar-size);height:var(--waline-avatar-size);margin:0 auto;border:var(--waline-border);border-radius:var(--waline-avatar-radius)}@media(width *:first-child{margin-top:0}.wl-card .wl-content>*:last-child{margin-bottom:0}.wl-card .wl-admin-actions{margin:8px 0;font-size:12px;text-align:right}.wl-card .wl-comment-status{margin:0 8px}.wl-card .wl-comment-status .wl-btn{border-radius:0}.wl-card .wl-comment-status .wl-btn:first-child{border-inline-end:0;border-radius:.5em 0 0 .5em}.wl-card .wl-comment-status .wl-btn:last-child{border-inline-start:0;border-radius:0 .5em .5em 0}.wl-card .wl-quote{border-inline-start:1px dashed rgba(237,237,237,.5)}.wl-card .wl-quote .wl-user{--avatar-size: var(--waline-m-avatar-size)}.wl-close-icon{color:var(--waline-border-color)}.wl-content .vemoji,.wl-content .wl-emoji{display:inline-block;vertical-align:baseline;height:1.25em;margin:-0.125em .25em}.wl-content .wl-tex{background:var(--waline-info-bgcolor);color:var(--waline-info-color)}.wl-content span.wl-tex{display:inline-block;margin-inline-end:.25em;padding:2px 4px;border-radius:.2em;font-size:var(--waline-info-font-size);line-height:1.5}.wl-content p.wl-tex{text-align:center}.wl-content .katex-display{overflow:auto hidden;-webkit-overflow-scrolling:touch;padding-top:.2em;padding-bottom:.2em}.wl-content .katex-display::-webkit-scrollbar{height:3px}.wl-content .katex-error{color:red}.wl-count{flex:1;font-weight:bold;font-size:1.25em}.wl-empty{overflow:auto;padding:1.25em;color:var(--waline-color);text-align:center}.wl-operation{text-align:center}.wl-operation button{margin:1em 0}.wl-power{padding:.5em 0;color:var(--waline-light-grey);font-size:var(--waline-info-font-size);text-align:end}.wl-meta-head{display:flex;flex-direction:row;align-items:center;padding:.375em}.wl-sort{margin:0;list-style-type:none}.wl-sort li{display:inline-block;color:var(--waline-info-color);font-size:.75em;cursor:pointer}.wl-sort li.active{color:var(--waline-theme-color)}.wl-sort li+li{margin-inline-start:1em}.wl-reaction{overflow:auto hidden;margin-bottom:1.75em;text-align:center}.wl-reaction img{width:100%;height:100%;transition:all 250ms ease-in-out}.wl-reaction-title{margin:16px auto;font-weight:bold;font-size:18px}.wl-reaction-list{display:flex;flex-direction:row;gap:16px;justify-content:center;margin:0;padding:8px;list-style-type:none}@media(width code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.wl-content .token.comment,.wl-content .token.block-comment,.wl-content .token.prolog,.wl-content .token.doctype,.wl-content .token.cdata{color:#999}.wl-content .token.punctuation{color:#ccc}.wl-content .token.tag,.wl-content .token.attr-name,.wl-content .token.namespace,.wl-content .token.deleted{color:#e2777a}.wl-content .token.function-name{color:#6196cc}.wl-content .token.boolean,.wl-content .token.number,.wl-content .token.function{color:#f08d49}.wl-content .token.property,.wl-content .token.class-name,.wl-content .token.constant,.wl-content .token.symbol{color:#f8c555}.wl-content .token.selector,.wl-content .token.important,.wl-content .token.atrule,.wl-content .token.keyword,.wl-content .token.builtin{color:#cc99cd}.wl-content .token.string,.wl-content .token.char,.wl-content .token.attr-value,.wl-content .token.regex,.wl-content .token.variable{color:#7ec699}.wl-content .token.operator,.wl-content .token.entity,.wl-content .token.url{color:#67cdcc}.wl-content .token.important,.wl-content .token.bold{font-weight:bold}.wl-content .token.italic{font-style:italic}.wl-content .token.entity{cursor:help}.wl-content .token.inserted{color:green}.wl-recent-item p{display:inline}.wl-user-list{padding:0;list-style:none}.wl-user-list a,.wl-user-list a:hover,.wl-user-list a:visited{color:var(--waline-color);text-decoration:none}.wl-user-list .wl-user-avatar{position:relative;display:inline-block;overflow:hidden;margin-inline-end:10px;border-radius:4px;line-height:0}.wl-user-list .wl-user-avatar>img{width:var(--waline-user-avatar-size, 48px);height:var(--waline-user-avatar-size, 48px)}.wl-user-list .wl-user-badge{position:absolute;bottom:0;inset-inline-end:0;min-width:.7em;height:1.5em;padding:0 .4em;border-radius:4px;background:var(--waline-info-bgcolor);color:var(--waline-info-color);font-weight:bold;font-size:10px;line-height:1.5em;text-align:center}.wl-user-list .wl-user-item{margin:10px 0}.wl-user-list .wl-user-item:nth-child(1) .wl-user-badge{background:var(--waline-rank-gold-bgcolor, #fa3939);color:var(--waline-white);font-weight:bold}.wl-user-list .wl-user-item:nth-child(2) .wl-user-badge{background:var(--waline-rank-silver-bgcolor, #fb811c);color:var(--waline-white);font-weight:bold}.wl-user-list .wl-user-item:nth-child(3) .wl-user-badge{background:var(--waline-rank-copper-bgcolor, #feb207);color:var(--waline-white)}.wl-user-list .wl-user-meta{display:inline-block;vertical-align:top}.wl-user-list .wl-badge{display:inline-block;vertical-align:text-top;margin-inline-start:.5em;padding:0 .3em;border:1px solid var(--waline-badge-color);border-radius:4px;color:var(--waline-badge-color);font-size:var(--waline-badge-font-size)}.wl-user-wall{padding:0;list-style:none}.wl-user-wall .wl-user-badge,.wl-user-wall .wl-user-meta{display:none}.wl-user-wall .wl-user-item{position:relative;display:inline-block;transition:transform ease-in-out .2s}.wl-user-wall .wl-user-item::before,.wl-user-wall .wl-user-item::after{position:absolute;bottom:100%;left:50%;z-index:10;opacity:0;pointer-events:none;transition:all .18s ease-out .18s;transform:translate(-50%, 4px);transform-origin:top}.wl-user-wall .wl-user-item::before{content:\"\";width:0;height:0;border:5px solid rgba(0,0,0,0);border-top-color:rgba(16,16,16,.95)}.wl-user-wall .wl-user-item::after{content:attr(aria-label);margin-bottom:10px;padding:.5em 1em;border-radius:2px;background:rgba(16,16,16,.95);color:#fff;font-size:12px;white-space:nowrap}.wl-user-wall .wl-user-item:hover{transform:scale(1.1)}.wl-user-wall .wl-user-item:hover::before,.wl-user-wall .wl-user-item:hover::after{opacity:1;pointer-events:none;transform:translate(-50%, 0)}.wl-user-wall .wl-user-item img{width:var(--waline-user-avatar-size, 48px);height:var(--waline-user-avatar-size, 48px)}/*# sourceMappingURL=waline.css.map */"},{"title":"","date":"2023-08-16T13:42:44.483Z","updated":"2023-08-16T13:42:44.483Z","comments":true,"path":"js/waline.js","permalink":"https://xinonria.top/js/waline.js","excerpt":"","text":"!function(e,t){if(\"function\"==typeof define&&define.amd)define(\"Waline\",[\"exports\"],t);else if(\"undefined\"!=typeof exports)t(exports);else{var n={exports:{}};t(n.exports),e.Waline=n.exports}}(\"undefined\"!=typeof globalThis?globalThis:\"undefined\"!=typeof self?self:this,(function(e){Object.defineProperty(e,\"__esModule\",{value:!0}),e.version=e.pageviewCount=e.init=e.defaultLocales=e.commentCount=e.UserList=e.RecentComments=void 0;const t=[\"nick\",\"mail\",\"link\"],n=e=>e.filter((e=>t.includes(e))),r=[\"//unpkg.com/@waline/emojis@1.1.0/weibo\"],l=\"en-US\",i=[\"//unpkg.com/@waline/emojis/tieba/tieba_agree.png\",\"//unpkg.com/@waline/emojis/tieba/tieba_look_down.png\",\"//unpkg.com/@waline/emojis/tieba/tieba_sunglasses.png\",\"//unpkg.com/@waline/emojis/tieba/tieba_pick_nose.png\",\"//unpkg.com/@waline/emojis/tieba/tieba_awkward.png\",\"//unpkg.com/@waline/emojis/tieba/tieba_sleep.png\"],o=e=>new Promise(((t,n)=>{if(e.size>128e3)return n(new Error(\"File too large! File size limit 128KB\"));const r=new FileReader;r.readAsDataURL(e),r.onload=()=>{var e;return t((null===(e=r.result)||void 0===e?void 0:e.toString())||\"\")},r.onerror=n})),s=e=>!0===e?'Tex is not available in preview':'Tex is not available in preview',a=e=>{const t=async function(t){return fetch(`https://api.giphy.com/v1/gifs/${t}?${new URLSearchParams({lang:e,limit:\"20\",rating:\"g\",api_key:\"6CIMLkNMMOhRcXPoMCPkFy4Ybk2XUiMp\",...arguments.length>1&&void 0!==arguments[1]?arguments[1]:{}}).toString()}`).then((e=>e.json())).then((e=>{let{data:t}=e;return t.map((e=>({title:e.title,src:e.images.downsized_medium.url})))}))};return{search:e=>t(\"search\",{q:e,offset:\"0\"}),default:()=>t(\"trending\",{}),more:function(e){return t(\"search\",{q:e,offset:(arguments.length>1&&void 0!==arguments[1]?arguments[1]:0).toString()})}}},c=new RegExp(`(${/[\\u4E00-\\u9FFF\\u3400-\\u4dbf\\uf900-\\ufaff\\u3040-\\u309f\\uac00-\\ud7af\\u0400-\\u04FF]+|\\w+/.source}|${/{let t=0;return e.replace(c,((e,n,r)=>{if(r)return`${r}`;if(\"io[e];function so(e,t){if(t){if(to.test(e))return e.replace(no,oo)}else if(ro.test(e))return e.replace(lo,oo);return e}const ao=/&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/gi;function co(e){return e.replace(ao,((e,t)=>\"colon\"===(t=t.toLowerCase())?\":\":\"#\"===t.charAt(0)?\"x\"===t.charAt(1)?String.fromCharCode(parseInt(t.substring(2),16)):String.fromCharCode(+t.substring(1)):\"\"))}const uo=/(^|[^\\[])\\^/g;function po(e,t){e=\"string\"==typeof e?e:e.source,t=t||\"\";const n={replace:(t,r)=>(r=(r=r.source||r).replace(uo,\"$1\"),e=e.replace(t,r),n),getRegex:()=>new RegExp(e,t)};return n}const ho=/[^\\w:]/g,fo=/^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;function go(e,t,n){if(e){let t;try{t=decodeURIComponent(co(n)).replace(ho,\"\").toLowerCase()}catch(e){return null}if(0===t.indexOf(\"javascript:\")||0===t.indexOf(\"vbscript:\")||0===t.indexOf(\"data:\"))return null}t&&!fo.test(n)&&(n=function(e,t){vo[\" \"+e]||(mo.test(e)?vo[\" \"+e]=e+\"/\":vo[\" \"+e]=xo(e,\"/\",!0));const n=-1===(e=vo[\" \"+e]).indexOf(\":\");return\"//\"===t.substring(0,2)?n?t:e.replace(yo,\"$1\")+t:\"/\"===t.charAt(0)?n?t:e.replace(wo,\"$1\")+t:e+t}(t,n));try{n=encodeURI(n).replace(/%25/g,\"%\")}catch(e){return null}return n}const vo={},mo=/^[^:]+:\\/*[^/]*$/,yo=/^([^:]+:)[\\s\\S]*$/,wo=/^([^:]+:\\/*[^/]*)[\\s\\S]*$/,bo={exec:function(){}};function ko(e,t){const n=e.replace(/\\|/g,((e,t,n)=>{let r=!1,l=t;for(;--l>=0&&\"\\\\\"===n[l];)r=!r;return r?\"|\":\" |\"})).split(/ \\|/);let r=0;if(n[0].trim()||n.shift(),n.length>0&&!n[n.length-1].trim()&&n.pop(),n.length>t)n.splice(t);else for(;n.length0)return{type:\"space\",raw:t[0]}}code(e){const t=this.rules.block.code.exec(e);if(t){const e=t[0].replace(/^ {1,4}/gm,\"\");return{type:\"code\",raw:t[0],codeBlockStyle:\"indented\",text:this.options.pedantic?e:xo(e,\"\\n\")}}}fences(e){const t=this.rules.block.fences.exec(e);if(t){const e=t[0],n=function(e,t){const n=e.match(/^(\\s+)(?:```)/);if(null===n)return t;const r=n[1];return t.split(\"\\n\").map((e=>{const t=e.match(/^\\s+/);if(null===t)return e;const[n]=t;return n.length>=r.length?e.slice(r.length):e})).join(\"\\n\")}(e,t[3]||\"\");return{type:\"code\",raw:e,lang:t[2]?t[2].trim().replace(this.rules.inline._escapes,\"$1\"):t[2],text:n}}}heading(e){const t=this.rules.block.heading.exec(e);if(t){let e=t[2].trim();if(/#$/.test(e)){const t=xo(e,\"#\");this.options.pedantic?e=t.trim():t&&!/ $/.test(t)||(e=t.trim())}return{type:\"heading\",raw:t[0],depth:t[1].length,text:e,tokens:this.lexer.inline(e)}}}hr(e){const t=this.rules.block.hr.exec(e);if(t)return{type:\"hr\",raw:t[0]}}blockquote(e){const t=this.rules.block.blockquote.exec(e);if(t){const e=t[0].replace(/^ *>[ \\t]?/gm,\"\"),n=this.lexer.state.top;this.lexer.state.top=!0;const r=this.lexer.blockTokens(e);return this.lexer.state.top=n,{type:\"blockquote\",raw:t[0],tokens:r,text:e}}}list(e){let t=this.rules.block.list.exec(e);if(t){let n,r,l,i,o,s,a,c,u,p,d,h,f=t[1].trim();const g=f.length>1,v={type:\"list\",raw:\"\",ordered:g,start:g?+f.slice(0,-1):\"\",loose:!1,items:[]};f=g?`\\\\d{1,9}\\\\${f.slice(-1)}`:`\\\\${f}`,this.options.pedantic&&(f=g?f:\"[*+-]\");const m=new RegExp(`^( {0,3}${f})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`);for(;e&&(h=!1,t=m.exec(e))&&!this.rules.block.hr.test(e);){if(n=t[0],e=e.substring(n.length),c=t[2].split(\"\\n\",1)[0].replace(/^\\t+/,(e=>\" \".repeat(3*e.length))),u=e.split(\"\\n\",1)[0],this.options.pedantic?(i=2,d=c.trimLeft()):(i=t[2].search(/[^ ]/),i=i>4?1:i,d=c.slice(i),i+=t[1].length),s=!1,!c&&/^ *$/.test(u)&&(n+=u+\"\\n\",e=e.substring(u.length+1),h=!0),!h){const t=new RegExp(`^ {0,${Math.min(3,i-1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`),r=new RegExp(`^ {0,${Math.min(3,i-1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`),l=new RegExp(`^ {0,${Math.min(3,i-1)}}(?:\\`\\`\\`|~~~)`),o=new RegExp(`^ {0,${Math.min(3,i-1)}}#`);for(;e&&(p=e.split(\"\\n\",1)[0],u=p,this.options.pedantic&&(u=u.replace(/^ {1,4}(?=( {4})*[^ ])/g,\" \")),!l.test(u))&&!o.test(u)&&!t.test(u)&&!r.test(e);){if(u.search(/[^ ]/)>=i||!u.trim())d+=\"\\n\"+u.slice(i);else{if(s)break;if(c.search(/[^ ]/)>=4)break;if(l.test(c))break;if(o.test(c))break;if(r.test(c))break;d+=\"\\n\"+u}s||u.trim()||(s=!0),n+=p+\"\\n\",e=e.substring(p.length+1),c=u.slice(i)}}v.loose||(a?v.loose=!0:/\\n *\\n *$/.test(n)&&(a=!0)),this.options.gfm&&(r=/^\\[[ xX]\\] /.exec(d),r&&(l=\"[ ] \"!==r[0],d=d.replace(/^\\[[ xX]\\] +/,\"\"))),v.items.push({type:\"list_item\",raw:n,task:!!r,checked:l,loose:!1,text:d}),v.raw+=n}v.items[v.items.length-1].raw=n.trimRight(),v.items[v.items.length-1].text=d.trimRight(),v.raw=v.raw.trimRight();const y=v.items.length;for(o=0;o\"space\"===e.type)),t=e.length>0&&e.some((e=>/\\n.*\\n/.test(e.raw)));v.loose=t}if(v.loose)for(o=0;o({text:e}))),align:t[2].replace(/^ *|\\| *$/g,\"\").split(/ *\\| */),rows:t[3]&&t[3].trim()?t[3].replace(/\\n[ \\t]*$/,\"\").split(\"\\n\"):[]};if(e.header.length===e.align.length){e.raw=t[0];let n,r,l,i,o=e.align.length;for(n=0;n1&&void 0!==arguments[1]?arguments[1]:[];return this.inlineQueue.push({src:e,tokens:t}),t}inlineTokens(e){let t,n,r,l,i,o,s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],a=e;if(this.tokens.links){const e=Object.keys(this.tokens.links);if(e.length>0)for(;null!=(l=this.tokenizer.rules.inline.reflinkSearch.exec(a));)e.includes(l[0].slice(l[0].lastIndexOf(\"[\")+1,-1))&&(a=a.slice(0,l.index)+\"[\"+_o(\"a\",l[0].length-2)+\"]\"+a.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex))}for(;null!=(l=this.tokenizer.rules.inline.blockSkip.exec(a));)a=a.slice(0,l.index)+\"[\"+_o(\"a\",l[0].length-2)+\"]\"+a.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);for(;null!=(l=this.tokenizer.rules.inline.escapedEmSt.exec(a));)a=a.slice(0,l.index+l[0].length-2)+\"++\"+a.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex),this.tokenizer.rules.inline.escapedEmSt.lastIndex--;for(;e;)if(i||(o=\"\"),i=!1,!(this.options.extensions&&this.options.extensions.inline&&this.options.extensions.inline.some((n=>!!(t=n.call({lexer:this},e,s))&&(e=e.substring(t.raw.length),s.push(t),!0)))))if(t=this.tokenizer.escape(e))e=e.substring(t.raw.length),s.push(t);else if(t=this.tokenizer.tag(e))e=e.substring(t.raw.length),n=s[s.length-1],n&&\"text\"===t.type&&\"text\"===n.type?(n.raw+=t.raw,n.text+=t.text):s.push(t);else if(t=this.tokenizer.link(e))e=e.substring(t.raw.length),s.push(t);else if(t=this.tokenizer.reflink(e,this.tokens.links))e=e.substring(t.raw.length),n=s[s.length-1],n&&\"text\"===t.type&&\"text\"===n.type?(n.raw+=t.raw,n.text+=t.text):s.push(t);else if(t=this.tokenizer.emStrong(e,a,o))e=e.substring(t.raw.length),s.push(t);else if(t=this.tokenizer.codespan(e))e=e.substring(t.raw.length),s.push(t);else if(t=this.tokenizer.br(e))e=e.substring(t.raw.length),s.push(t);else if(t=this.tokenizer.del(e))e=e.substring(t.raw.length),s.push(t);else if(t=this.tokenizer.autolink(e,Eo))e=e.substring(t.raw.length),s.push(t);else if(this.state.inLink||!(t=this.tokenizer.url(e,Eo))){if(r=e,this.options.extensions&&this.options.extensions.startInline){let t=1/0;const n=e.slice(1);let l;this.options.extensions.startInline.forEach((function(e){l=e.call({lexer:this},n),\"number\"==typeof l&&l>=0&&(t=Math.min(t,l))})),t=0&&(r=e.substring(0,t+1))}if(t=this.tokenizer.inlineText(r,Ro))e=e.substring(t.raw.length),\"_\"!==t.raw.slice(-1)&&(o=t.raw.slice(-1)),i=!0,n=s[s.length-1],n&&\"text\"===n.type?(n.raw+=t.raw,n.text+=t.text):s.push(t);else if(e){const t=\"Infinite loop on byte: \"+e.charCodeAt(0);if(this.options.silent){console.error(t);break}throw new Error(t)}}else e=e.substring(t.raw.length),s.push(t);return s}}class Lo{constructor(e){this.options=e||eo}code(e,t,n){const r=(t||\"\").match(/\\S*/)[0];if(this.options.highlight){const t=this.options.highlight(e,r);null!=t&&t!==e&&(n=!0,e=t)}return e=e.replace(/\\n$/,\"\")+\"\\n\",r?''+(n?e:so(e,!0))+\"\\n\":\"\"+(n?e:so(e,!0))+\"\\n\"}blockquote(e){return`\\n${e}\\n`}html(e){return e}heading(e,t,n,r){return this.options.headerIds?`${e}\\n`:`${e}\\n`}hr(){return this.options.xhtml?\"\\n\":\"\\n\"}list(e,t,n){const r=t?\"ol\":\"ul\";return\"\\n\"+e+\"\\n\"}listitem(e){return`${e}\\n`}checkbox(e){return\" \"}paragraph(e){return`${e}\\n`}table(e,t){return t&&(t=`${t}`),\"\\n\\n\"+e+\"\\n\"+t+\"\\n\"}tablerow(e){return`\\n${e}\\n`}tablecell(e,t){const n=t.header?\"th\":\"td\";return(t.align?``:``)+e+`\\n`}strong(e){return`${e}`}em(e){return`${e}`}codespan(e){return`${e}`}br(){return this.options.xhtml?\"\":\"\"}del(e){return`${e}`}link(e,t,n){if(null===(e=go(this.options.sanitize,this.options.baseUrl,e)))return n;let r='"}],"posts":[{"title":"vue+fastapi搭建","slug":"vue-fastapi搭建","date":"2024-05-21T16:07:21.000Z","updated":"2024-05-29T08:59:17.750Z","comments":true,"path":"posts/de646dc/","permalink":"https://xinonria.top/posts/de646dc/","excerpt":"本文将一个Vue框架打包的资源挂载到Fastapi上，解决了assets文件404导致Vue页面白屏问题。","text":"本文将一个Vue框架打包的资源挂载到Fastapi上，解决了assets文件404导致Vue页面白屏问题。 前言 学校一个大作业要求开发一个系统，拥有web界面以及对用户上传文件进行数据处理。 web前端打算选择使用Vue框架，后端框架使用简单易上手的Fastapi。 现在把搭建的流程走一遍。 搭建前端框架 在目录里面使用Vue官方脚手架创建项目。(请确保电脑上已安装Node.js，如未安装则无法使用npm) 123456789101112npm create vue@latestVue.js - The Progressive JavaScript Framework√ 请输入项目名称： ... frontend√ 是否使用 TypeScript 语法？ ... 否 / 是√ 是否启用 JSX 支持？ ... 否 / 是√ 是否引入 Vue Router 进行单页面应用开发？ ... 否 / 是√ 是否引入 Pinia 用于状态管理？ ... 否 / 是√ 是否引入 Vitest 用于单元测试？ ... 否 / 是√ 是否要引入一款端到端（End to End）测试工具？ » 不需要√ 是否引入 ESLint 用于代码质量检测？ ... 否 / 是√ 是否引入 Vue DevTools 7 扩展用于调试? (试验阶段) ... 否 / 是 这里项目命名为frontend，除了使用Vue Router和Pinia之外其他都选否。 (当然也可酌情选择，其他选项可让代码更规范，不过由于独立开发以效率优先就没选) 接下来按照说明执行一下这三条命令。 如卡在npm install这步可在网上了解一下如何设置npm镜像源(注意内容时效性，例如淘宝源修改域名，某些源由公开转为私有) 123cd frontendnpm installnpm run dev 输入完npm run dev后可以打开http://localhost:5173/，此时即可看到效果。 搭建后端框架 在目录下新建文件夹backend用于存放后端文件，进入backend文件夹。 为了防止Python环境污染，通过venv创建一个虚拟环境并进入。 12python -m venv .venv.\\.venv\\Scripts\\activate 注意venv环境无法指定Python版本，venv环境会使用创建它的python版本。 进入虚拟环境后可输入python -V查看版本。 我的Python版本为3.10.12。 安装fastapi框架。 1pip install fastapi 稍等片刻后安装完成，在backend目录下新建main.py文件作为fastapi的入口。 12345678# ./backend/main.pyfrom fastapi import FastAPIapp = FastAPI()@app.get(&quot;/&quot;)def read_root(): return &#123;&quot;Hello&quot;: &quot;World&quot;&#125; 随后在终端输入uvicorn main:app --reload --port 8001启动应用。 在浏览器打开http://127.0.0.1:8001即可看到效果。 http://127.0.0.1:8001/docs可查看fastapi默认生成的文档 此时项目目录如下图: 前端获取后端数据 前端需要加个包axios用来向后端发送数据。 后端需要设置CORS来允许跨域访问。 前端部分 回到.\\frontend，输入npm install axios来安装包。 安装后修改.\\frontend\\src\\main.js来导入这个包。 123456789101112// frontend\\src\\main.js...import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;import axios from &#x27;axios&#x27;axios.defaults.baseURL = &#x27;http://localhost:8001/api/&#x27;axios.defaults.withCredentials = trueconst app = createApp(App)... 修改.\\frontend\\src\\app.vue来向后端发送请求。 1234567891011121314151617181920212223242526272829303132&lt;script setup&gt;import &#123; RouterLink, RouterView &#125; from &#x27;vue-router&#x27;;import HelloWorld from &#x27;./components/HelloWorld.vue&#x27;;import &#123; ref &#125; from &#x27;vue&#x27;;import axios from &#x27;axios&#x27;;const message = ref(&#x27;Empty message&#x27;);const handleClick = () =&gt; &#123; axios.get(&#x27;/button&#x27;).then((res) =&gt; &#123; message.value = res.data; &#125;);&#125;&lt;/script&gt;&lt;template&gt; &lt;header&gt; &lt;img alt=&quot;Vue logo&quot; class=&quot;logo&quot; src=&quot;@/assets/logo.svg&quot; width=&quot;125&quot; height=&quot;125&quot; /&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;HelloWorld :msg=&quot;message&quot; /&gt; &lt;button @click=&quot;handleClick&quot;&gt;click me!&lt;/button&gt; &lt;nav&gt; &lt;RouterLink to=&quot;/&quot;&gt;Home&lt;/RouterLink&gt; &lt;RouterLink to=&quot;/about&quot;&gt;About&lt;/RouterLink&gt; &lt;/nav&gt; &lt;/div&gt; &lt;/header&gt; &lt;RouterView /&gt;&lt;/template&gt;... 此时点击按钮并不会发生什么反应，我们在console里可以发现出现了什么问题。 上述错误信息提示跨域访问不成功，这需要在服务器后端来配置。 后端部分 修改main.py添加CORS即可。 123456789101112131415161718192021# backend\\main.pyfrom fastapi import FastAPIfrom fastapi.middleware.cors import CORSMiddlewareapp = FastAPI()app.add_middleware( CORSMiddleware, allow_origins= &quot;http://localhost:5174/&quot;, allow_credentials=True, allow_methods=[&quot;*&quot;], allow_headers=[&quot;*&quot;], )@app.get(&quot;/&quot;)def read_root(): return &#123;&quot;Hello&quot;: &quot;World&quot;&#125;@app.get(&quot;/api/button&quot;)def read_button(): return &quot;You clicked the button!&quot; 此时点击按钮即可获取到消息。 打包Vue文件 对于目前全栈来说每次都要分别启动前端服务和后端服务未免有些繁琐，因此我们选择将Vue文件打包成html和若干个js与css文件，通过静态文件挂载到fastapi上，这样只需要启动后端就可以了。 修改build路径 来到frontend\\vite.config.js里修改一下。 1234567891011121314151617181920// frontend\\vite.config.jsimport &#123; fileURLToPath, URL &#125; from &#x27;node:url&#x27;import &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;export default defineConfig(&#123; plugins: [ vue(), ], resolve: &#123; alias: &#123; &#x27;@&#x27;: fileURLToPath(new URL(&#x27;./src&#x27;, import.meta.url)) &#125; &#125;, // 新增 build: &#123; outDir: &#x27;../backend/static&#x27;, &#125;&#125;) 接着npm run build即可打包。 挂载静态文件 再回到后端main.js挂载一下。 将对应内容修改为: 1234567891011121314151617181920212223242526# backend\\main.pyfrom fastapi import FastAPIfrom fastapi.middleware.cors import CORSMiddlewarefrom fastapi.responses import FileResponsefrom fastapi.staticfiles import StaticFilesapp = FastAPI()app.add_middleware( CORSMiddleware, allow_origins= &quot;http://127.0.0.1:8001/&quot;, # 注意此处修改为127.0.0.1:8001 allow_credentials=True, allow_methods=[&quot;*&quot;], allow_headers=[&quot;*&quot;],)app.mount(&quot;/static&quot;, StaticFiles(directory=&quot;static&quot;), name=&quot;static&quot;)app.mount(&#x27;/assets&#x27;, StaticFiles(directory=&#x27;static/assets&#x27;), name=&#x27;assets&#x27;)@app.get(&quot;/&quot;)def root(): return FileResponse(&#x27;static/index.html&#x27;)@app.get(&quot;/api/button&quot;)def read_button(): return &quot;You clicked the button!&quot; 许多教程并没有mount assets文件夹，导致页面白屏 最后这一句话导致找了几天的bug，不过总算把这个框架搭建完了。 后续开发也许还要注意一下资源的路径问题。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://xinonria.top/tags/vue/"},{"name":"fastapi","slug":"fastapi","permalink":"https://xinonria.top/tags/fastapi/"}]},{"title":"手把手带你实现一个响应式系统","slug":"通俗易懂的响应系统原理","date":"2024-04-03T02:51:45.000Z","updated":"2024-04-04T19:28:56.913Z","comments":true,"path":"posts/8feee3db/","permalink":"https://xinonria.top/posts/8feee3db/","excerpt":"本文探究了Vue.js中响应式系统的实现，通过介绍副作用函数与响应式数据，利用Proxy实现了一个相对完善的响应系统，同时讨论了分支切换导致冗余副作用的清理问题。","text":"本文探究了Vue.js中响应式系统的实现，通过介绍副作用函数与响应式数据，利用Proxy实现了一个相对完善的响应系统，同时讨论了分支切换导致冗余副作用的清理问题。 副作用函数 如果我们使用js中的某个函数改变了html标签里的某个内容，由于在这个函数以外的地方都能访问或者设置这个html标签的内容 所以我们说这个函数可能会直接或者间接影响到其他函数的执行，也就是产生了副作用。 12345const obj = &#123; text: &#x27;nihao&#x27; &#125;// effect函数产生了副作用function effect() &#123; document.body.innerText = obj.text&#125; 响应式数据 还是上面的代码: 1234567const obj = &#123; text: &#x27;nihao&#x27; &#125;// effect函数执行会读取obj.textfunction effect() &#123; document.body.innerText = obj.text&#125;obj.text = &quot;hello&quot; 在effect中我们将body.innerText与obj.text的值绑定在了一起。 朴素做法 我们的所希望的是body.innerText总是显示obj.text，要达到这个效果，只要每次修改obj.text的时候都调用一次effect就行了。 12345678910111213const obj = &#123; text: &#x27;nihao&#x27; &#125;// effect函数执行会读取obj.textfunction effect() &#123; document.body.innerText = obj.text&#125;effect()obj.text = &quot;hello&quot;effect()obj.text = &quot;like&quot;effect()... 这未免也有些太麻烦了，我们是否可以让js智能一点？ 在每次修改obj的时候调用一下所有会读取obj内容的副作用函数。 这样我们就把obj变成了所谓的响应式数据。 基本实现响应式数据 按照前面的说法，我们需要在obj被读取的时候，把这个函数给记录下来，作为obj的副作用函数。 在obj被修改的时候，把之前记录下来的关于它的副作用函数再调用一遍。 接下来的关键在于如何拦截obj的读取和修改操作。 Vue.js 3使用ES2015+中的代理对象Proxy来实现这个拦截操作。 Proxy代理对象 根据MDN文档中对Proxy的说明: 语法 1new Proxy(target, handler) Proxy会对target(可以是任意类型)进行包装，最后返回一个Proxy对象。 handler: 一个对象，其属性是定义了在对代理执行操作时的行为的函数。 正常情况下我们不能拦截target的一些行为，但我们使用Proxy把它&quot;绑架&quot;之后，返回的一个跟它一模一样的Proxy对象就可以被我们拦截了。 在这里我们只拦截对target的读取和修改操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 存储当前的副作用函数let activeEffect// effect用于注册副作用函数function effect(fn) &#123; activeEffect = fn fn() activeEffect = null&#125;// 使用Set来存储副作用函数const effectFuncs = new Set()const data = &#123; text: &#x27;nihao&#x27; &#125;// 劫持dataconst obj = new Proxy(data, &#123; // 拦截读取操作 get(target, key) &#123; // 记录副作用函数 effectFuncs.add(activeEffect) // 返回属性 return target[key] &#125;, // 拦截修改操作 set(target, key, newVal) &#123; // 先修改 target[key] = newVal // 再调用所有副作用函数 effectFuncs.forEach(fn =&gt; fn()) // 表示设置成功 return true &#125;&#125;)// 一个匿名的副作用函数, 用于更新页面effect(() =&gt; &#123; document.body.innerText = obj.text&#125;)// 修改响应式数据setTimeout(() =&gt; &#123; obj.text = &#x27;hello&#x27;&#125;, 2000) 当页面运行的时候第一个副作用函数被调用，把obj.text绑定到body.innerText上， 同时将这个副作用函数放到Set内，以便以后调用。 当时间经过2s后，obj受到修改，同时调用与之相关的副作用函数(也就是前一个绑定obj.text到body.innerText的副作用函数)，更新body.innerText的值。 细心的读者可能发现上面的代码有些不合适，我们的劫持操作是对obj整个对象来做的 同时副作用函数也绑定在整个对象上。 如果我们修改obj对象，但是我们修改的是obj别的属性(例如value)，似乎也会触发对set()的劫持，把所有绑定到obj上的副作用函数都调用一遍。 我们应该让副作用函数跟对象的属性绑定在一起，如下图的结构: effect1和effect2会读取obj1.text属性，所以在修改obj1.text属性的时候应该执行这两个函数。 effect1和effect3会读取obj1.value属性，所以在修改obj1.value属性的时候应该执行这两个函数。 现在修改一下上面的代码: 只存储涉及副作用函数的对象和属性，并不是追踪所有属性。 下文所有对象、属性都为跟副作用函数的有关的对象和属性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647let activeEffect// 存储对象，对象-&gt;属性const bucket = new WeakMap() // 后文解释为什么这里用WeakMapconst obj = new Proxy(data, &#123; get(target, key) &#123; // 将当前对象的属性和副作用函数关联 track(target, key); return target[key]; &#125;, set(target, key, newVal) &#123; target[key] = newVal; // 当属性发生变化时，触发所有副作用函数 trigger(target, key); return true; &#125;&#125;);function track(target, key) &#123; // 不是通过副作用函数读取的属性，直接return if (!activeEffect) return target[key]; // 获取当前target的属性，depsMap类型为Map，存储属性-&gt;副作用函数 let depsMap = bucket.get(target); // 当前对象还没有属性 if (!depsMap) &#123; bucket.set(target, (depsMap = new Map())); &#125; // 获取当前属性的副作用函数，类型为Set，存储副作用函数 let deps = depsMap.get(key); // 当前属性还没有存储副作用函数 if (!deps) &#123; depsMap.set(key, (deps = new Set())); &#125; // 将当前副作用函数存储进Set中 deps.add(activeEffect);&#125;function trigger(target, key) &#123; // 获得当前对象的属性 const depsMap = bucket.get(target); // 当前对象不存在涉及副作用函数的属性 if (!depsMap) return; // 获得当前属性的副作用函数 const effects = depsMap.get(key); effects &amp;&amp; effects.forEach(fn =&gt; fn());&#125; weakMap 根据MDN文档中对weakMap的说明: weakMap和Map很相似，但区别在于 不会阻止垃圾回收，直到垃圾回收器移除了键对象的引用 任何值都可以被垃圾回收，只要它们的键对象没有被 WeakMap 以外的地方引用 weakMap不会阻止它的键被垃圾回收，一旦键的生命周期结束，键被垃圾回收了，那么weakMap的键值对也都会被回收。 我们使用weakMap存储对象-&gt;属性的原因也在于此。 如果这个响应式数据被销毁了或是生命周期结束了，那么它所存储的那些副作用函数都应该被释放。这样才能避免发生内存泄露。 现在让我们来尝试使用一下这个简单的响应式数据。 123456./index.html&lt;body&gt; &lt;div class=&quot;div1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div2&quot;&gt;&lt;/div&gt; &lt;script src=&quot;./js/my.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; 123456789101112131415161718192021./js/my.jsconst data = &#123;text: &#x27;nihao&#x27;, value: 1&#125;;...const div1 = document.querySelector(&#x27;.div1&#x27;);const div2 = document.querySelector(&#x27;.div2&#x27;);effect(function effect1() &#123; div1.innerHTML = obj.text;&#125;);effect(function effect2() &#123; div2.innerHTML = obj.value;&#125;);setTimeout(() =&gt; &#123; obj.text = &#x27;hello world&#x27;;&#125;, 1000);setTimeout(() =&gt; &#123; obj.value = 2;&#125;, 2000); effect1和effect2被注册为副作用函数。 在读取obj.text和obj.value的时候被get方法劫持，将对应的副作用函数与obj对应的属性绑定。 1234obj -&gt; text -&gt; effect1 | | -&gt; value -&gt; effect2 过了1s之后，修改obj.text的值，被set方法劫持，得到text属性对应的所有副作用函数effect1，重新执行effect1函数，更新页面。 过了2s之后，修改obj.value的值，被set方法劫持，得到value属性对应的所有副作用函数effect2，重新执行effect2函数，更新页面。 优化分支切换 分支切换 也许我们可能会根据对象的某个属性的值来执行不同的操作，如果某个操作分支当中又发生了get操作，那么可能会产生遗留的副作用函数。 12345const data = &#123;text: &#x27;hello world&#x27;, ok: true&#125;;...effect(function effect1() &#123; div1.innerHTML = obj.ok ? obj.text : &#x27;not&#x27;;&#125;) 这里的三元运算就产生了分支操作。 当obj.ok的值为真时，读取obj.text的值，触发两次get操作(读取ok一次，读取text一次)，所以让effect1这个函数被绑定在ok和text属性上。 1234obj -&gt; ok -&gt; effect1 | | -&gt; text -&gt; effect1 如果我们修改obj.text的值时，调用effect1函数，更新页面内容。 如果我们修改obj.ok的值时，也会调用effect1函数 但由于ok控制了分支切换，如果它为false，那么div1内容就是固定的not，与obj.text无关了。 但由于obj.text仍然绑定着这个effect1副作用函数，修改obj.text仍然会重新执行effect1函数，尽管这并不会导致页面更新(因为obj.ok此时为false)。 理想情况下我们希望在obj.ok为false的时候解除obj.text对effect1的绑定，因为obj.text已经与这个副作用函数脱钩了。 解决的思路也简单，我们需要在每次副作用函数执行的时候先把它自己从所有与之有关的对象属性中删除，称为cleanup操作。 在副作用函数执行的过程中重新把自己添加进相应的对象属性中。 还是上面的例子: obj.ok为true，读取了obj.ok与obj.text，所以把副作用函数绑定到了这两个属性上。 接下来修改obj.ok为false，触发set方法，调用effect1函数。 在调用的时候先把effect1从所有属性上脱离绑定，接着运行函数。 触发对obj.ok的读取，触发get方法，把effect1重新注册到obj.ok属性上。 读取到当前obj.ok为false，显示not。(不会触发读取obj.text的操作，因此effect1不会被注册到obj.text上了) 接下来就是实现以上思路了。 我们需要完成两个操作: 收集effect1与哪些属性绑定的信息 对绑定了effect1的属性进行cleanup操作 既然要收集信息，所以我们要先创建一个list来用于存放相关的对象属性。 修改一下注册副作用函数时的effect函数与track函数与trigger函数。 123456789101112131415161718192021222324252627282930313233343536// 存储当前的副作用函数let activeEffectfunction effect(fn) &#123; // 清理副作用函数 function cleanup() &#123; effectFn.deps.forEach(dep =&gt; &#123; dep.delete(effectFn); &#125;); effectFn.deps.length = 0; &#125; const effectFn = () =&gt; &#123; cleanup(); activeEffect = effectFn; fn(); activeEffect = null; &#125;; effectFn.deps = []; effectFn();&#125;...// 收集属性function track(target, key) &#123; ... // 收集当前属性包含的副作用函数，放到触发set操作的副作用函数的deps里 activeEffect.deps.push(deps);&#125;function trigger(target, key) &#123; ... // 创建一个新的effectsToRun来使用forEach，否则会在执行副作用函数的时候先cleanup接着再次添加进Set，这样子会进入死循环 const effectsToRun = new Set(effects); effectsToRun.forEach(fn =&gt; fn());&#125; 感谢您阅读到这里，本文就先写到这里吧。 响应式系统还有更多复杂的内容，例如effect函数嵌套和调度执行，以及computed和watch等属性，这些内容以后再写写吧。 我的理解和分析很大程度上得益于《Vue.js 设计与实现》一书 (作者:霍春阳)。书中对响应系统的实现原理进行了深入的讲解，为我撰写本文提供宝贵的参考。在此我向霍春阳先生表示衷心的感谢。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://xinonria.top/tags/vue/"},{"name":"前端","slug":"前端","permalink":"https://xinonria.top/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"记一次痛苦流配置环境过程","slug":"记一次痛哭流配置环境过程","date":"2024-03-24T05:19:49.000Z","updated":"2024-04-02T13:48:34.850Z","comments":true,"path":"posts/c2eb3971/","permalink":"https://xinonria.top/posts/c2eb3971/","excerpt":"","text":"对象 GNN4EEG 官方搭建过程 Install Anaconda with Python &gt;= 3.5 Clone the repository 1git clone https://github.com/Miracle-2001/GNN4EEG.git Install requirements and step into the src folder 123cd GNN4EEGcd srcpip install -r requirements.txt 如果在 Windows 上按照以上过程，恭喜你，十有八九会卡在pip install -r requirements.txt这一步。 可能会出现的错误包括但不限于: eeg-positions安装失败 mkl-fft==1.3.1安装失败 pyg-lib找不到对应版本 torch-cluster等工具链找不到对应版本 配置全过程 eeg-positions 与 mkl-fft 安装失败 报错信息: 1ERROR: Package &#x27;eeg-positions&#x27; requires a different Python: 3.6.15 not in &#x27;&gt;=3.7&#x27; 挺好懂的，版本过低嘛。 实际通过.ipynb 文件源码能发现作者用的压根不是 3.5，而是3.10。 但当时的我还没发现(后面用 git diff 才发现的…), 尝试 3.7, 3.8, 3.9 等多个版本后发现Python3.9能够正常安装上这两个包。 pyg-lib找不到对应版本 报错信息: 123ERROR: Ignored the following versions that require a different python version: 2.5.2 Requires-Python !=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,&lt;3.9dev,&gt;=2.7ERROR: Could not find a version that satisfies the requirement pyg-lib==0.2.0+pt113cu116 (from versions: none)ERROR: No matching distribution found for pyg-lib==0.2.0+pt113cu116 其他人也都大部分卡在这个地方过不去。它说没有找到对应的版本，那我们就去Pypi上看看到底有哪些版本。 pyg-lib 官网上面说可以用这个命令安装: 1pip install pyg-lib -f https://data.pyg.org/whl/torch-$&#123;TORCH&#125;+$&#123;CUDA&#125;.html 哦？后面的那个网址可能就是安装源了吧，对应 torch1.13.0 和 cu116 进去看看，能不能手动下载下来呢？ 网址 不是这啥啊，怎么全是 linux 呢？ 回去再看看官网 呃呃，幽默 windows。 咋整吧，上 Linux 咯。 WSL 安装过程 Linux 我们又不用它图形化界面，能让我输指令就行了，所以装个 wsl 吧。 添加功能 在开始菜单搜索启用或关闭Windows功能，把Hyper-V, Windows虚拟机监控程序平台, 适用于Linux的Windows子系统给勾上。 家庭版不能勾哦，整个专业版 Windows 吧。 虚拟化内核 接着检查一下 cpu 虚拟化开了没，没开的要在 BIOS 上开开。 安装 ubuntu 直接 cmd 输入安装就可以啦。 1wsl --install 请保证你的 C 盘有至少 20G 空闲空间。 结果安装失败了。 1Please enable the Virtual Machine Platform Windows feature and ensure virtualization is enabled in the BIOS. 不是，我不是已经开了吗？又在网上找教程。 教程 最后在 cmd 又输入了bcdedit /set hypervisorlaunchtype auto成功启动 ubuntu 并且设置密码。 以上每一输入一次指令后都建议重启一下哦。 迁移 ubuntu 由于后续还要下很多东西，wsl 默认安装到 C 盘上了。为了避免红盘，应该将我们得 linux 迁移到别的盘里。 按照这个教程走就没什么问题,这里就不赘述了。 教程 (记得 export 的时候别忘了带后缀名.tar，以及提前建好文件夹放进去) 完善 ubuntu 上线后照例更新一下 apt 包管理器。 1sudo apt update &amp;&amp; apt upgrade 这里要再装一个g++，不然后面的torch工具链无法 setup。 1sudo apt install g++ 这边为了看能不能调用 cuda 我还装了个 cudatoolkit。(不知道有没有影响，但我确实这么做了) 1sudo apt install cudatoolkit 为了避免环境污染(保护地球环境)，这里装个 miniconda 用来建 conda 环境。 去清华源下个最新版: https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/ 在我们的 ubuntu 里下方便点。 123wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-latest-Linux-x86_64.shMiniconda3-latest-Linux-x86_64.shsource ~/.bashrc 安装一路 yes 过去，最后那步是为了激活我们安装的 conda。 创建环境 找个目录git clone https://github.com/Miracle-2001/GNN4EEG.git一下仓库。 然后就是创建 conda 环境。 12conda create -n gnn4eeg python==3.9conda activate gnn4eeg ok 了，接下来回到最开始的目标，手动安装一下该死的pyg-lib 安装完成后记得在 requirements.txt 把它给删了。 1pip install pyg-lib -f https://data.pyg.org/whl/torch-2.0.1+cu121.html (至于这里为什么不是 torch1.13 和 cu116 原因如下) torch-cluster 等工具链 这里感觉可能 torch 版本跟 cuda 对不上(cuda 是 12.1)，由于作者用的是 torch1 的末尾版本，所以感觉上 torch2 应该没问题。 这里看 Pypi 官网上面的安装说明。 12pip install torch torchvision torchaudiopip install pyg_lib torch_scatter torch_sparse torch_cluster torch_spline_conv -f https://data.pyg.org/whl/torch-2.0.0+cu121.html 如果以上都完成了的话再安装一遍 requirements.txt。 1pip install -r requirements.txt 运行 这里先建一个test.py看看。 123import torchimport pyg_libprint(torch.cuda.is_available()) 如果能运行出True就大功告成了。 如果最后末尾是这种类似错误那就是 cuda 和 torch 版本对不上，去查一下文档玩版本消消乐吧。 1OSError: libtorch_cuda_cpp.so: cannot open shared object file: No such file or directory 成功了那就去运行一下样例文件example_dgcnn_cross2.py吧。 前面 import 都能通过的话就看到胜利曙光了。 sklearn 版本错误 requirements.txt 里面 sklearn 指定版本是 0.0.0？有点怪，把它pip uninstall sklearn后再安装一下pip install sklearn。 版本依赖已经不管啦 hdf5 导入出错 运行到 loader 那就报错了。 12...__init__() missing 1 required positional argument: &#x27;version&#x27; 检查了一下是 hdf5 的问题，反正都是读入 matlab 文件，你不行我换一个库呗。 在ge/protocols.py里面的 135 行data = hdf5.loadmat(data_path)['de_lds']改成用scipy.io来导入 mat 文件。 123import scipy.io as scio...data = scio.loadmat(data_path)[&#x27;de_lds&#x27;] 找不到设备 这些能够一直跑到训练模型了，但是又报错了。 1RuntimeError: CUDA error: invalid device ordinal CUDA kernel errors might be asynchronously reported at some other API call, so the stacktrace below might be incorrect. For debugging consider passing CUDA_LAUNCH_BLOCKING=1. Compile with `TORCH_USE_CUDA_DSA` to enable device-side assertions. 看看我有哪些 gpu 以及编号。 1nvidia-smi 确实检测到了 gpu，但为啥不学习呢？ 在example_dgcnn_cross2.py第 31 行。 1device=torch.device(&#x27;cuda:3&#x27;) 我哪有 4 路交火的 gpu？把 3 改成 0 就可以了。 成功! 最后看到这个结果的时候感动得要哭出来了快。 目前跑一个 epoch 要 10 秒左右，跑一轮设置为 100 个 epoch，再加上 27 行的K=10，应该是要跑 1000 次，大概快三个小时的样子。 不过这个模型大概 epoch 在 30 到 50 次左右就差不多收敛了，可以看看设置个早停优化一下。 源码到时候再研究一下吧。 下面是配置好的 fork 仓库。 链接","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://xinonria.top/tags/python/"},{"name":"machine_learning","slug":"machine-learning","permalink":"https://xinonria.top/tags/machine-learning/"}]},{"title":"一个Next.js项目的总结 - 1","slug":"一个Next-js项目的总结","date":"2024-03-02T11:48:01.000Z","updated":"2024-04-02T13:48:34.836Z","comments":true,"path":"posts/8188f4d4/","permalink":"https://xinonria.top/posts/8188f4d4/","excerpt":"","text":"前面的话 之前就有些 React 基础，这次借着学习 Next.js 的机会把 React 的知识巩固一下，同时也尝试从 JavaScript 过渡到 TypeScript 上面，同时有了 CSS 的基础之后使用 tailwindcss 也更顺手了。 项目效果 地址 由于部署在 Vercel 上，也许要科学上网才能访问。 适配移动端以及桌面端。 知识点 Router 系统 主要页面文件都在 App 文件夹内。 其中 ui 文件夹放需要用到的组件，lib 文件夹放与服务端相关的 ts 文件。 页面则放在以页面名命名的文件夹内，约定以page.tsx作为页面文件。 可选layout.tsx作为覆盖进同层级以及子层级的页面文件。 例如@/app/dashboard/layout.tsx为侧边导航栏。 静态路由 不同页面之间可以使用&lt;Link&gt;&lt;/Link&gt;，不使用&lt;a /&gt;标签跳转。例如 12345&lt;Link href=&quot;/login&quot; className=&quot;flex items-center gap-5 self-start rounded-lg bg-blue-500 px-6 py-3 text-sm font-medium text-white transition-colors hover:bg-blue-400 md:text-base&quot;&gt; &lt;span&gt;Log in&lt;/span&gt; &lt;ArrowRightIcon className=&quot;w-5 md:w-6&quot; /&gt;&lt;/Link&gt; &lt;Link&gt;标签内可以塞入别的标签。 在 ts 文件内还可以使用redirect('/dashboard/invoices');重定向到页面。 动态路由 当不确定路由地址的时候可以使用动态路由，例如博客地址，个人界面。 可以使用中括号[]包括路由名来创建动态路由，例如[blog],[id]。 导航的时候使用模板字符串就行了，在页面组件的地方接收一下。 12345678// 导航&lt;Link href=`/dashboard/invoices/$&#123;id&#125;/edit`&gt;&lt;/Link&gt;// 接收export default async function Page(&#123; params &#125;: &#123; params: &#123; id: string &#125; &#125;) &#123; const id = params.id; // ...&#125; 逻辑组 可以使用圆括号()来声明一个逻辑组。逻辑组的名称不会出现在 url 中，但会影响loading.tsx与layout.tsx的工作。 例如要创建dashboard的loading界面，但我们不想让这个loading界面应用到别的页面，可以创建一个逻辑组来阻止loading界面扩散。 1/dashboard/(overview) / page.tsx / dashboard / overview / loading.tsx; 流式加载 loading 页面 上文提到了loading页面。 由于网站的时间花费主要集中在网络与存取数据库上，所以为了对用户友好，可以使用流式加载。 在还没加载好的时候提前给出一个页面，加载完成后再显示数据。 例如loading.tsx就可以在当前页面还没渲染好的时候，提前发送给用户显示。 流式传输组件 除了页面可以流式传输，组件也可以流式传输。我们先传输加载完成的组件给用户，还未加载好的组件就保持加载状态。 可以使用&lt;Suspense&gt;标签实现这个功能。 123&lt;Suspense fallback=&#123;&lt;RevenueChartSkeleton /&gt;&#125;&gt; &lt;RevenueChart /&gt;&lt;/Suspense&gt; &lt;RevenueChart /&gt;是加载完毕的数据。 而&lt;Suspense&gt;标签的 fallback 属性就是还在加载中显示的组件。 …待续","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://xinonria.top/tags/react/"},{"name":"前端","slug":"前端","permalink":"https://xinonria.top/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"计算区间次数的方法","slug":"计算区间次数的方法","date":"2024-02-25T16:24:59.000Z","updated":"2024-04-02T13:48:34.849Z","comments":true,"path":"posts/e2b2f835/","permalink":"https://xinonria.top/posts/e2b2f835/","excerpt":"","text":"原题背景 可以直接跳到核心 原题链接 分析 可以贪心，选择买卡还是不买卡的关键在于这段铁路会被访问多少次 1s[i].money = min(s[i].a*s[i].vis, s[i].c+s[i].b*s[i].vis) 核心 如何统计这段铁路会被访问多少次呢？(注意左闭右开原则) 给出多组i 与 j 要让 i 到 j 的每个数组中的成员 vis+1 例如： s[i].vis+1,s[i+1].vis+1,…,s[j].vis+1 如果暴力 for 循环对每段赋值的话是会超时的。 123for (int i = from; i &lt; to; ++i) &#123; s[i].vis++;&#125; 线段树或者树状数组或许可以完成，但没必要 解决方法 我们在开始的位置+1，并在结尾的位置-1。最后再求前缀和，得到的就是每段的访问次数了。 例如 从车站 1 -&gt; 5 和 1 -&gt; 4。 (下方表示第 i 段铁路，到达站点五，并不会经过第 5 段铁路) 应该出现的结果是: 第 i 段铁路 1 2 3 4 5 访问次数 2 2 2 1 0 按照我们的方法: 第 i 段铁路 1 2 3 4 5 访问次数 +1+1 0 0 -1 -1 对这个数组求前缀和: 第 i 段铁路 1 2 3 4 5 访问次数 2 2 2 1 0 如此，我们只需要循环一遍就能够完成对区间访问次数的计数了。 代码 123456789101112131415161718// 多次调用，处理每个区间头尾void addVis(int a, int b)&#123; if (a &gt; b) &#123; swap(a, b); &#125; stations[a].vis++; stations[b].vis--;&#125;void solve()&#123; ... // 如果压根从来不会经过的站台，就没必要计算了 for (int i = min_city; i &lt;= max_city; i++) &#123; stations[i].vis += stations[i - 1].vis; &#125;&#125;","categories":[],"tags":[{"name":"前缀和","slug":"前缀和","permalink":"https://xinonria.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"}]},{"title":"react-1","slug":"react-1","date":"2023-12-15T07:46:24.000Z","updated":"2024-04-02T13:48:34.835Z","comments":true,"path":"posts/116f1cdc/","permalink":"https://xinonria.top/posts/116f1cdc/","excerpt":"","text":"JSX 概念 JSX是JavaScript和XML（HTML）的缩写，表示在JS代码中编写HTML模版结构。它是React中编写UI模版的方式。 例如: 123456789const message=&#x27;this is message&#x27;;function App () &#123; return ( &lt;div&gt; &lt;h1&gt;this is title&lt;/h1&gt; &#123;message&#125; &lt;/div&gt; )&#125; 优势 HTML的声明式模版写法 JS的可编程能力 劣势 HTML与JS组合在一起阅读有些困难 本质 JSX并不是标准的JS语法，是JS的语法拓展,浏览器本身无法识别，通过解析工具后在浏览器中运行。 JSX中使用JS表达式 识别表达式 在JSX中可以通过大括号语法识别JavaScript中的表达式。 使用引号传递字符串 使用JavaScript变量 函数调用和方法调用 使用JavaScript对象 例如 123456789101112131415161718const number = 1;const getName = () =&gt; &#x27;Xinon&#x27;;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &#123;/* 使用引号传入字符串 */&#125; &#123;&#x27;this is a message from js&#x27;&#125; &#123;/* 使用变量 */&#125; &#123;number&#125; &#123;/* 使用函数 */&#125; &#123;getName()&#125; &#123;/* 使用方法 */&#125; &#123; new Date().getDate() &#125; &#123;/* 使用js对象 */&#125; &#123; &lt;div style=&#123;&#123;color: &#x27;red&#x27;&#125;&#125;&gt;this is div&lt;/div&gt; &#125; &lt;/div&gt; )&#125; 实现列表渲染 在JSX中使用原生JS中的map方法遍历渲染列表 map() 方法创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。 例如 123456789const lists = [&#123;id: 1, name: &#x27;a&#x27;&#125;,&#123;id: 2, name: &#x27;b&#x27;&#125;,&#123;id: 3, name: &#x27;c&#x27;&#125;];&lt;ul&gt; &#123;list.map(item =&gt; (&lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;))&#125;&lt;/ul&gt; 注意 在渲染li标签的时候，React要求每个元素上面要绑定一个key值(独一无二)，可以是字符串也可以是数字。 作用 React框架内部使用 提升更新性能 实现条件渲染 基础条件渲染 逻辑与运算符&amp;&amp; 三元表达式( ? : ) 例如 12&#123;flag &amp;&amp; &lt;span&gt;Only display when flag is true&lt;/span&gt;&#125;&#123;loading? &lt;span&gt;loading...&lt;/span&gt; : &lt;span&gt;Not loading&lt;/span&gt;&#125; 复杂条件渲染 如果出现多种条件的渲染应该怎么写呢？ 这个时候就需要使用自定义函数+if判断语句 例如 123456789function getType(type) &#123; if (type === 1) return &lt;div&gt;1&lt;/div&gt; else if (type === 2) return &lt;div&gt;2&lt;/div&gt; else return &lt;div&gt;3&lt;/div&gt;&#125;...&#123;getType(2)&#125;... 事件绑定 语法 on + 事件名称 = &#123;事件处理程序&#125;，整体上遵循驼峰命名法 123456const handleClick = () =&gt; &#123; console.log(&#x27;hit&#x27;);&#125;...&lt;button onClick=&#123;handleClick&#125;&gt;click me&lt;/button&gt; 使用事件对象参数 语法 在事件回调函数中设置形参e。 12345const handleClick = (e) =&gt; &#123; console.log(e);&#125;;...&lt;button onClick=&#123;handleClick&#125;&gt;click me&lt;/button&gt; 传递自定义参数 语法 事件绑定的位置改造为箭头函数的写法，在执行clickHandler的时候传递实参。 注意 ！不能直接写函数调用，事件绑定需要一个函数引用 12345const handleClick = (name) =&gt; &#123; console.log(name);&#125;;...&lt;button onClick=&#123;() =&gt; handleClick(&#x27;xinon&#x27;)&#125;&gt;click&lt;/button&gt;&#125;&gt; 同时传递事件对象和自定义参数 语法 在事件绑定的位置传递事件实参e和自定义参数，clickHandler中声明形参，注意位置对应。 123456const handleClick = (e, name) =&gt; &#123; console.log(e); console.log(name);&#125;;...&lt;button onClick=&#123;(e) =&gt; handleClick(e, &#x27;xinon&#x27;)&#125;&gt;click&lt;/button&gt;&#125;&gt; 组件 概念 一个组件就是用户界面的一部分，它可以有自己的逻辑和外观，组件之间可以互相嵌套，也可以复用多次。 React组件 在React中，一个组件就是首字母大写的函数，内部存放了组件的逻辑和视图UI，渲染组件只需要把组件当做标签书写即可。 例如 123456789101112131415// 1.定义组件function Button() &#123; return &lt;button&gt;click me&lt;/button&gt;&#125;// 2. 使用组件function App() &#123; return &lt;div className=&quot;App&quot;&gt; &#123;/* 自闭合 */&#125; &lt;Button /&gt; &#123;/* 成对标签 */&#125; &lt;Button&gt;&lt;/Button&gt; &lt;/div&gt;&#125; 样式处理 1. 行内样式(不推荐) 1&lt;div style=&#123;&#123;color: &#x27;red&#x27;&#125;&#125;&gt;this is a div&lt;/div&gt; 最外层的{}表示要使用JS表达式,内层的{}表示构造一个对象. 2. class类名控制 样式写在css内,文件头处导入css. 1234/* index.css */.foo &#123; color: red;&#125; 12345/* App.js */import &#x27;./index.css&#x27;...&lt;span className=&quot;foo&quot;&gt;this is a span&lt;/div&gt;... 注意原来的class要写作className。 useState(重要) 基础使用 useState是一个React Hook(函数)，它允许我们向组件添加一个状态变量，从而控制影响组件的渲染结果。 文件头使用import &#123; useState &#125; from 'react'导入函数. 本质 和普通JS变量不用的是，状态变量一旦发生变化，组件的视图UI也会跟着变化(数据驱动视图) 状态变量改变之后React知道这个状态变了就会重新更新渲染. 如果只是js的let变量改变了,React框架并不知道是否更新,也就不会同步渲染. 语法 const [count, setCount] = useState(0); useState是一个函数,返回值是一个数组 数组中的第一个参数是状态变量,第二个参数是set函数用来修改状态变量 useState的参数作为count的初始值 例如 1234567891011121314151617// 修改变量const [count, setCount] = useState(0);const handleClick = () =&gt; &#123; //直接修改不会更新 // ++count; // 调用setCount，每次都是替换count的值 setCount(count + 1);&#125;;// 修改对象const [form, setForm] = useState(&#123;name: &#x27;xinon&#x27;&#125;);const handleClick = () =&gt; &#123; setForm(&#123; ...form, //展开form里的所有元素 name: &#x27;xinonria&#x27; //替换里面的name &#125;)&#125; 修改状态规则 状态不可变 在React中,状态被认为是只读的,我们应该始终替换它而不是修改它,直接修改状态不能引发视图更新. 不能直接用=来设置状态变量的值,这样子不会更新渲染! 修改状态用对应的set函数","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://xinonria.top/tags/react/"}]},{"title":"MATLAB作图","slug":"MATLAB作图","date":"2023-10-26T12:36:55.000Z","updated":"2024-04-02T13:48:34.833Z","comments":true,"path":"posts/ff74d260/","permalink":"https://xinonria.top/posts/ff74d260/","excerpt":"","text":"MATLAB作图 曲线图 MATLAB作图是通过描点、连线来实现的，故在画一个曲线图形之前，必须先取得该图形上的一系列的点的坐标（即横坐标和纵坐标），然后将该点集的坐标传给MATLAB函数画图。 plot(X,Y,S) X,Y为向量，分别表示点集的横坐标和纵坐标 S表示连线的类型 y 黄色 . 点 - 连线 m 洋红 o 圈 : 短虚线 c 蓝绿色 x x-符号 -. 长短线 r 红色 + 加号 – 长虚线 plot(X,Y1,S1,X,Y2,S2,...,X,Yn,Sn) 将多条线画在一起 例如: 在[0,2π][0, 2\\pi][0,2π]用红线画sin(x)sin(x)sin(x)，用绿圈画cos(x)cos(x)cos(x) 1234x=linspace(0,2.*pi,30);y=sin(x);z=cos(x);plot(x,y,&#x27;r&#x27;,x,z,&#x27;go&#x27;) 符号函数(显函数、隐函数和参数方程)画图 fplot('fun',lims) 表示绘制字符串funfunfun指定的函数在lims=[xmin,xmax]lims=[x_{min},x_{max}]lims=[xmin​,xmax​]的图形. fun必须是M文件的函数名或是独立变量为x的字符串. fplot函数不能画参数方程和隐函数图形，但在一个图上可以画多个图形. 例如: 在[−1，2][-1，2][−1，2]上画y=e2x+sin(3x2)y=e^{2x}+sin(3x^2)y=e2x+sin(3x2)的图形。 先建M文件myfun1.m 12function Y=myfun1(x) Y=exp(2*x)+sin(3*x.^2) 再输入命令 fplot(‘myfun1’,[-1,2]) 对数坐标图 在很多工程问题中,通过对数据进行对数转换可以更清晰地看出数据的某些特征,在对数坐标系中描绘数据点的曲线,可以直接地表现对数转换. 对数转换有双对数坐标转换和单轴对数坐标转换两种. 用loglog函数可以实现双对数坐标转换. 用semilogx和semilogy函数可以实现单轴对数坐标转换. 对数坐标就是它的数值增长跟到原点的距离不是线性关系，而是对数关系。 例如正常横坐标轴:x→1,2,3,...,nx \\rightarrow 1,2,3,...,nx→1,2,3,...,n 而对数坐标轴就是:x→101,102,103,...,10nx \\rightarrow 10^1,10^2,10^3,...,10^nx→101,102,103,...,10n 在对于变化量激增的数据来说对数坐标轴比较好表示 三维图形 空间曲线 一条曲线 plot3(x,y,z,s) x,y,zx,y,zx,y,z表示曲线上点集的横坐标、纵坐标、纵坐标。 sss表示连线的类型，见上文 例如: 在区间[0,10π][0,10\\pi][0,10π]画出参数曲线x=sint,y=cost,z=tx=sint,y=cost,z=tx=sint,y=cost,z=t. 12t=0:pi/50:10*pi;plot3(sin(t),cos(t),t) 多条曲线 plot3(x,y,z) 其中x,y,zx,y,zx,y,z是都是m×nm×nm×n矩阵，其对应的每一列表示一条曲线. 例如: 画多条曲线观察函数Z=(X+Y)2Z=(X+Y)^2Z=(X+Y)2 1234x=-3:0.1:3;y=1:0.1:5;[X,Y]=meshgrid(x,y);Z=(X+Y).^2;plot3(X,Y,Z) 展开讲一讲meshgrid这个函数。 在文档中的应用是[X, Y]=meshgrid(x,y) 基于向量xxx和yyy中包含的坐标返回二维网格坐标。坐标XXX和YYY表示的网格有length(y)length(y)length(y)个行和length(x)length(x)length(x)个列。 例子 可以注意到，列数跟xxx是相同的，行数跟yyy是相同的。 在XXX中可以看到数据只有我们输入的xxx，YYY同理。 XXX是一行行摆数据，而YYY是一列列摆数据。 空间曲面 surf(x,y,z) surf(x,y,z)分别表示数据点的横坐标、纵坐标、函数值。 画出数据点(x,y,z)(x,y,z)(x,y,z)表示的曲面。 例如: 画函数Z=(X+Y)2Z=(X+Y)^2Z=(X+Y)2的图形. 123456x=-3:0.1:3;y=1:0.1:5;[X,Y]=meshgrid(x,y);Z=(X+Y).^2;surf(X,Y,Z)shading flat %将当前图形变得平滑 有点美耶… mesh(x,y,z) mesh(x,y,z)画网格曲面。 例如: 画出曲面Z=(X+Y)2Z=(X+Y)^2Z=(X+Y)2在不同视角的网格图。 12345x=-3:0.1:3;y=1:0.1:5;[X,Y]=meshgrid(x,y);Z=(X+Y).^2;mesh(X,Y,Z) 感觉还是surf好看 meshz(X,Y,Z) meshz(x,y,z)在网格周围画一个curtain图(如,参考平面) ?看不懂了 例如: 绘peaks的网格图 123[X,Y]=meshgrid(-3:.125:3);Z=peaks(X,Y);meshz(X,Y,Z) 图形处理 在图形上加格栅、图例和标注 加格栅 GRID ON加格栅在当前图上 GRID OFF删除格栅 开了格栅，关了格栅就没有浅灰色的那些线 加图例 xlabel(string)在当前图形的x轴上加图例string ylabel(string)在当前图形的y轴上加图例string zlabel(string)在当前图形的z轴上加图例string title(string)在当前图形的顶端上加图例string 这个二维坐标系没有z轴，不过大差不差 加标注 gtext(‘string’) 命令gtext(‘string’)用鼠标放置标注在现有的图上. 运行命令gtext('string')时，屏幕上出现当前图形，在图形上出现一个交叉的十字，该十字随鼠标的移动移动，当按下鼠标左键时，该标注string放在当前十交叉的位置. 输完命令之后图像会出现一个十字标，选择一个位置左键一下就可以标注函数名称了。 定制坐标 axis([xmin xmax ymin ymax zmin zmax])定制图形坐标 x、y、z的最大、最小值 axis auto将坐标轴返回到自动缺省值 可以看到axis限定了x轴和y轴的范围 图形保持 hold on 保持当前图形, 以便继续画图到当前图上 hold off 释放当前图形窗口 figure(h) 新建h窗口，激活图形使其可见，并把它置于其它图形之上 例如: 区间[0,2π][0,2\\pi][0,2π]新建两个窗口分别画出y=sin(x),z=cos(x)y=sin(x),z=cos(x)y=sin(x),z=cos(x). 123456789x=linspace(0,2*pi,100);y=sin(x);z=cos(x);plot(x,y);title(&#x27;sin(x)&#x27;);pausefigure(2);plot(x,z);title(&#x27;cos(x)&#x27;); 割窗口 h=subplot(mrows,ncols,thisplot) 划分整个作图区域为mrows*ncols块（逐行对块访问）并激活第thisplot块，其后的作图语句将图形画在该块上. subplot(mrows,ncols,thisplot)激活已划分为mrows*ncols块的屏幕中的第thisplot块，其后的作图语句将图形画在该块上. subplot(1,1,1) 命令subplot(1,1,1)返回非分割状态. subplot(2,2,1)表示把屏幕分成2∗22*22∗2，在第一块上画图。 例如 将屏幕分割为四块，并分别画出y=sin(x)，z=cos(x)，a=sin(x)×cos(x),b=sin(x)cos(x)y=sin(x)，z=cos(x)，a=sin(x)\\times cos(x),b=\\frac{sin(x)}{cos(x)}y=sin(x)，z=cos(x)，a=sin(x)×cos(x),b=cos(x)sin(x)​. 12345678x=linspace(0,2*pi,100);y=sin(x); z=cos(x); a=sin(x).*cos(x);b=sin(x)./(cos(x)+eps)subplot(2,2,1);plot(x,y),title(&#x27;sin(x)&#x27;)subplot(2,2,2);plot(x,z),title(&#x27;cos(x)&#x27;)subplot(2,2,3);plot(x,a),title(&#x27;sin(x)cos(x)&#x27;)subplot(2,2,4);plot(x,b),title(&#x27;sin(x)/cos(x)&#x27;) 缩放图形 zoom on 为当前图形打开缩放模式 单击鼠标左键，则在当前图形窗口中，以鼠标点中的点为中心的图形放大2倍；单击鼠标右键，则缩小2倍. zoom off 关闭缩放模式 没啥用 改变视角view view(a,b) 改变视角到(a,b)(a,b)(a,b),aaa是方位角,bbb为仰角.默认视角为(−37.5,30)(-37.5,30)(−37.5,30). view([x，y，z]) 用空间向量表示的，三个量只关心它们的比例，与数值的大小无关，xxx轴view([1,0,0])，yyy轴view([0,1,0])，zzz轴view([0,0,1]). 两个参数的用法：view(azimuth, elevation)，其中： azimuth（方位角）：这是水平旋转的角度。0度通常指向图形的正前方，正值将图形绕y轴逆时针旋转，负值将图形绕y轴顺时针旋转。 elevation（俯仰角）：这是垂直旋转的角度。0度通常表示视图位于图形的水平面上方，正值将视图上升，负值将视图下降. 结合分块可以画出不同视角的三维图 12345678x=-3:0.1:3;y=1:0.1:5;[X,Y]=meshgrid(x,y);Z=(X+Y).^2;subplot(2,2,1), mesh(X,Y,Z)subplot(2,2,2), mesh(X,Y,Z),view(50,-34) %表示以方位角 50 度和俯仰角 -34 度的视角观察图形.subplot(2,2,3), mesh(X,Y,Z),view(-60,70) %表示以方位角 -60 度和俯仰角 70 度的视角观察图形.subplot(2,2,4), mesh(X,Y,Z),view([0,1,1]) %只看y轴和z轴 动画 moviein(),getframe,movie() 函数moviein()产生一个帧矩阵来存放动画中的帧；函数getframe对当前的图像进行快照；函数movie()按顺序回放各帧. 例如: 将曲面peaks做成动画 123456789[x,y,z]=peaks(30);surf(x,y,z)axis([-3 3 -3 3 -10 10])m=moviein(15)for i=1:15 view(-37.5+24*(i-1),30) m(:,i)=getframe;endmovie(m) 旋转动画 特殊二、三维图形 特殊的二维图形函数 极坐标图 polar(theta,rho,s) 用角度theta(弧度表示)和极半径rho作极坐标图，用s指定线型. 例如: r=sin2θ×cos2θr=sin2\\theta\\times cos2\\thetar=sin2θ×cos2θ的极坐标图形 1234theta=linspace(0,2*pi)rho=sin(2*theta).*cos(2*theta);polar(theta,rho)title(&#x27;Polar plot of sin(2*theta).*cos(2*theta)&#x27;); 散点图 scatter(X,Y,S,C) 在向量XXX和YYY的指定位置显示彩色圈．XXX和YYY必须大小相同. 12load seamountscatter(x,y,5,z) seamount.mat 数据集包含了有关海底山脉的数据，其中包括海底山脉的位置坐标（经度和纬度）以及与每个位置相关的深度数据。这个数据集通常用于示范如何在 MATLAB 中创建各种类型的图表，如散点图、三维曲面图等，以展示地理或地形数据的可视化。 平面等值线图 contour(x,y,z,n) 绘制nnn个等值线的二维等值线图 例如: 在范围−2&lt;x&lt;2,−2&lt;y&lt;3-2 &lt; x &lt; 2,-2 &lt; y &lt; 3−2&lt;x&lt;2,−2&lt;y&lt;3 内绘 z=xe−x2−y2z=xe^{-x^2-y^2}z=xe−x2−y2的等值线图 12345［X,Y］=meshgeid(-2:.2:2,-2:.2:3);Z=X.*exp(-X.^2-Y.^2);[C,h]=contour(X,Y,Z); clabel(C,h) %如果没有这句话，等值线上就没有数字colormap cool %寒冷的cool，用冷色调着色，不是酷~~~ 特殊的三维图形函数 空间等值线图 contour3(x,y,z,n) 其中n表示等值线数. 例如: 山峰的二维和三维等值线图 12345678[x,y,z]=peaks;subplot(1,2,1),contour3(x,y,z,16,&#x27;s&#x27;) grid on,xlabel(&#x27;x-axis&#x27;),ylabel(&#x27;y-axis&#x27;)zlabel(&#x27;z-axis&#x27;)title(&#x27;contour3 of peaks&#x27;); subplot(1,2,2),contour(x,y,z,16,&#x27;s&#x27;)grid, xlabel(&#x27;x-axis&#x27;), ylabel(&#x27;y-axis&#x27;)title(&#x27;contour of peaks&#x27;); 三维散点图 scatter3(X,Y,Z,S,C) 在向量X,YX,YX,Y和ZZZ指定的位置上显示彩色圆圈. 向量X,YX,YX,Y和ZZZ的大小必须相同. 例如: 绘制三维散点图. 1234567[x,y,z]=sphere(16); %调用sphere函数会在当前的图形窗口中创建一个单位半径的球体，通常以灰色或其他默认颜色呈现。X=[x(:)*.5 x(:)*.75 x(:)];Y=[y(:)*.5 y(:)*.75 y(:)];Z=[z(:)*.5 z(:)*.75 z(:)];S=repmat([1 .75 .5]*10,prod(size(x)),1);C=repmat([1 2 3],prod(size(x)),1);scatter3(X(:),Y(:),Z(:),S(:),C(:),&#x27;filled&#x27;),view(-60,60) repmat()函数用法:B = repmat(A, m, n) A是要重复的数组或矩阵。 m是要在垂直方向重复的次数。 n是要在水平方向重复的次数。 B是生成的重复数组或矩阵。 prod()计算矩阵或数组中所有元素的乘积 size(x)返回x的行数和列数 所以prod(size(x))会得到这个矩阵的元素个数","categories":[],"tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://xinonria.top/tags/MATLAB/"}]},{"title":"MATLAB入门","slug":"MATLAB-1","date":"2023-10-25T09:14:45.000Z","updated":"2024-04-02T13:48:34.835Z","comments":true,"path":"posts/79214690/","permalink":"https://xinonria.top/posts/79214690/","excerpt":"","text":"前面的话 准备打数模竞赛，记录一下学习MATLAB的笔记。 最开始看到MATLAB个人版还挺贵的，想着既然有了edu邮箱能不能申请免费的学生版。 申请前还是有点担心SCNU没买MATLAB的教育版授权。 用edu邮箱注册后发现直接就有了学生版许可证。体验到了一把学校带来的福利，挺爽的。 MatLab入门 变量 命名规则 变量名必须是不含空格的单个词 变量名区分大小写 变量名最多不超过19个字符 变量名必须以字母打头，之后可以是任意字母、数字或下划线，变量名中不允许使用标点符号 看起来跟正常的编程语音命名规则差不多，不过区别在于第三条，平时可能也用不到 特殊变量表 所以eps相当于无穷小 数学运算符号及标点符号 正常乘法都用点乘，单一个*符号表示矩阵乘 数学函数 大部分还是比较好理解的，有什么用这个函数就叫什么，实在想不起来搜一下也行 M文件 MATLAB的内部函数是有限的，有时为了研究某一个函数的各种性态，需要为MATLAB定义新函数。 自定义函数 函数文件是文件名后缀为M的文件，这类文件的第一行必须是一特殊字符function开始，格式为： 1function 因变量名=函数名（自变量名） 函数值的获得必须通过具体的运算实现，并赋给因变量. 在命令行里输入edit '文件名.m'就可以打开编辑器，同时在编辑器里打开该文件，如果不存在就创建。创建前注意当前工作区路径。 定义函数例子 f(x1,x2)=100⋅(x2−x12)2+(1−x1)2f(x_1,x_2)=100\\cdot(x_2-x_1^2)^2+(1-x_1)^2f(x1​,x2​)=100⋅(x2​−x12​)2+(1−x1​)2 建立M文件: fun.m 12function f=fun(x)f=100*(x(2)-x(1)^2)^2+(1-x(1))^2 可以直接使用函数fun.m 例如：计算f(1,2)f(1,2)f(1,2)，只需要在MATLAB命令窗口键入命令: 12x=[1 2]fun(x) 数组 创建简单的数组 x=[a b c d e f]创建包含指定元素的行向量。 x=first:last 创建从first开始，步长为1，到last结束的行向量。 相当于python中的range(first,end) x=first:increment:last 创建从first开始，加increment计数，到last结束的行向量。 相当于python中的range(first,last,increment) x=linspace(first,last,n) 创建从first开始，到last结束，有n个元素的行向量。 linspace并没有指定步长，它一定会生成n个元素。例如linspace(1,10,2)会生成[1 3.25 5.5 7.75 10]这5个均匀分布的元素。 linspace跟上面的区别就是它的步长是不确定的，而上面的是个数不确定。例如1:5:10会以5为步长，生成的个数并没有确定，最终生成的数组是[1 6]（因为下一个要生成的是11，大于了last值10，所以最后只有两个数字） x=logspace(first，last，n) 创建从first开始，到last结束，有n个元素的对数分隔行向量。 这个真有点难理解。大概应该是会生成10first10^{first}10first到10last10^{last}10last，元素个数为nnn。元素之间的差值是指数级增长的。 例如:logspace(1,3,4)会生成[10 46.4158883361278 215.443469003188 1000]。它们两两元素之间的差值就是[36.4158883361278 169.027580667060 784.556530996812]。这三个数用指数函数来拟合可以得到: 指数 曲线拟合(exp1) f(x)=a∗exp(b∗x)f(x) = a*exp(b*x)f(x)=a∗exp(b∗x) 等价于f(x)=a∗eb⋅xf(x) = a * e^{b{\\cdot}x}f(x)=a∗eb⋅x 系数和 95% 置信边界 值 下限 上限 a 7.8456 7.8456 7.8456 b 1.5351 1.5351 1.5351 拟合优度 值 R 方 1.0000 可以看到R 方数值为1，说明指数函数完全拟合这个间距。 数组元素的访问 访问一个元素 x(i)表示访问数组xxx的第iii个元素。 访问一块元素 x(a:b:c)表示访问数组xxx的第aaa个元素开始，以步长bbb到第ccc个元素(但不超过ccc),bbb可以为负数，bbb若不填默认为111。 直接使用元素编址序号 x([a b c d])表示提取数组xxx的第a,b,c,da,b,c,da,b,c,d个元素构成一个新的数组[x(a) x(b) x(c) x(d)][x(a) \\space x(b) \\space x(c) \\space x(d)][x(a) x(b) x(c) x(d)]。 前面例子中的数组都是一行数列，是行方向分布的. 称之为行向量. 数组也可以是列向量，它的数组操作和运算与行向量是一样的，唯一的区别是结果以列形式显示. 产生列向量有两种方法: 直接产生，例c=[1;2;3;4] 以空格或逗号分隔的元素指定的是不同列的元素，而以分号分隔的元素指定了不同行的元素. 分号表示当前行结束 转置产生，例b=[1 2 3 4]; c=b′ 单引号(′&#x27;′)运算符是转置运算符，它可以将列转为行，行转为列。 例如x=[1 2 3 4]; x'的结果就是[1;2;3;4]。举个3∗33*33∗3矩阵的例子吧。 x=x =x= 1 2 3 4 5 6 7 8 9 x′=x&#x27; =x′= 1 4 7 2 5 8 3 6 9 数组的运算 数组对标量 数组对标量的加、减、乘、除和平方运算，是指数组的每个元素对该标量施加相应的加、减、乘、除、平方运算。 设：a=[a1,a2,…,an]a=[a_1,a_2,…,a_n]a=[a1​,a2​,…,an​], ccc是标量. a+c=[a1+c,a2+c,…,an+c]a+c=[a_1+c,a_2+c,…,a_n+c]a+c=[a1​+c,a2​+c,…,an​+c] a.∗c=[a1∗c,a2∗c,…,an∗c]a.*c=[a_1*c,a_2*c,…,a_n*c]a.∗c=[a1​∗c,a2​∗c,…,an​∗c] a./c=[a1/c,a2/c,…,an/c] (右除)a./c= [a_1/c,a_2/c,…,a_n/c] \\space (右除)a./c=[a1​/c,a2​/c,…,an​/c] (右除) a.\\c=[c/a1,c/a2,…,c/an] (左除)a. \\backslash c= [c/a_1,c/a_2,…,c/a_n] \\space (左除)a.\\c=[c/a1​,c/a2​,…,c/an​] (左除) a. \\^\\ c= [a_1 ^ c,a_2 ^ {c},…,a_n^{c}] c. \\^\\ a= [c ^ {a_1},c ^ {a_2},…,c^{a_n}] 数组对数组 当两个数组有相同维数时，加、减、乘、除、幂运算可按元素对元素方式进行，不同大小或维数的数组是不能进行运算的。 设：a=[a1,a2,…,an],b=[b1,b2,…,bn]a=[a_1,a_2,…,a_n], b=[b_1,b_2,…,b_n]a=[a1​,a2​,…,an​],b=[b1​,b2​,…,bn​] a+b=[a1+b1,a2+b2,…,an+bn]a+b=[a_1+b_1,a_2+b_2,…,a_n+b_n]a+b=[a1​+b1​,a2​+b2​,…,an​+bn​] a.∗b=[a1∗b1,a2∗b2,…,an∗bn]a.*b= [a_1*b_1,a_2*b_2,…,a_n*b_n]a.∗b=[a1​∗b1​,a2​∗b2​,…,an​∗bn​] a./b=[a1/b1,a2/b2,…,an/bn]a./b= [a_1/b_1,a_2/b_2,…,a_n/b_n]a./b=[a1​/b1​,a2​/b2​,…,an​/bn​] a.\\b=[b1/a1,b2/a2,…,bn/an]a. \\backslash b=[b_1/a_1,b_2/a_2,…,b_n/a_n]a.\\b=[b1​/a1​,b2​/a2​,…,bn​/an​] a. \\^\\ b=[a_1^{b_1},a_2^{b_2},…,a_n^{b_n}] 矩阵 逗号或空格用于分隔某一行的元素，分号用于区分不同的行. 除了分号，在输入矩阵时，按Enter键也表示开始新一行. 输入矩阵时，严格要求所有行有相同的列. 特殊矩阵的建立 a=ones(m,n) 产生一个m行n列的元素全为1的矩阵 b=zeros(m，n) 产生一个m行n列的零矩阵 c=[ ] 产生一个空矩阵，当对一项操作无结果时，返回空矩阵，空矩阵的大小为零 d=eye(m,n) 产生一个m行n列的单位矩阵 所谓的单位矩阵就是一个主对角线元素为111且其他位置元素为000的n⋅mn\\cdot mn⋅m矩阵。 矩阵中元素的操作 矩阵AAA的第rrr行 A(r,:) 矩阵AAA的第rrr列 A(:,r) 牢记逗号前后是先行后列 依次提取矩阵AAA的每一列，将AAA拉伸为一个列向量：A(:) [1 2 3;4 5 6;7 8 9]会变成[1;4;7;2;5;8;3;6;9]画一下就能明白了。 取矩阵AAA的第i1∼i2i_1 \\sim i_2i1​∼i2​行、第j1∼j2j_1 \\sim j_2j1​∼j2​列构成新矩阵:A(i1:i2, j1:j2) 以逆序提取矩阵AAA的第i1∼i2i_1 \\sim i_2i1​∼i2​行，构成新矩阵:A(i_2:-1:i_1,:) 以逆序提取矩阵AAA的第j1∼j2j_1 \\sim j_2j1​∼j2​行，构成新矩阵:A(:,j_2:-1:j_1) 删除AAA的第i1∼i2i_1 \\sim i_2i1​∼i2​行，构成新矩阵:A(i_1:i_2,:)=[] 赋值操作，赋值一个空数组 删除AAA的第j1∼j2j_1 \\sim j_2j1​∼j2​列，构成新矩阵:A(:,j_1:j_2)=[] 将矩阵A和B拼接成新矩阵：[A B]; [A;B] 拼接语句是这个[A;B] 矩阵的运算 标量-矩阵运算 标量-数组运算相同 矩阵-矩阵运算 (1) 元素对元素的运算，同数组-数组运算 (2) 矩阵运算 矩阵加法：A+B 矩阵乘法：A*B 方阵的行列式：det(A) 方阵的逆：inv(A) 方阵的特征值与特征向量: [V，D]=eig[A] 后面三个线代再慢慢理解吧，现在看都看不懂 关系与逻辑运算 逻辑运算符 关系运算符 逻辑运算符 控制流 MATLAB提供三种决策或控制流结构 for循环 while循环 if-elseif-else结构 for循环 允许一组命令以固定的和预定的次数重复 123for x=array &#123;commands&#125;end 在for和end语句之间的命令串{commands}按数组(array)中的每一列执行一次. 在每一次迭代中，x被指定为数组的下一列，即在第n次循环中，x=array(:,n) 例如: 对n=1,2,...,10n=1,2,...,10n=1,2,...,10,求xn=sin(n⋅π10)x_n=sin(\\frac{n \\cdot \\pi}{10})xn​=sin(10n⋅π​)的值。 123for n=1:10 x(n)=sin(n*pi/10);end while循环 与for循环以固定次数求一组命令相反，while循环以不定的次数求一组语句的值。 123while (expression) &#123;commands&#125;end 只要在表达式(expression)里的所有元素为真，就执行while和end语句之间的命令串{commands}。 if-elseif-else结构 有一个选择的一般形式是： 123if (expression)&#123;commands&#125;end 如果在表达式(expression)里的所有元素为真，就执行if和end语句之间的命令串{commands}. 例如: 123456789function f=fun2(x)if x&gt;1 f=x^2+1else if x&lt;=0 f=x^3 else f=2*x endend 练习 用起泡法对10个数由小到大排序. 即将相邻两个数比较,将小的调到前头。 这题其实就是冒泡排序，考察for循环的使用 12345678a=randi(10,[1 5]); %生成1~10的一个1x5的矩阵(其实就是一个有五个元素的数组)for i=1:length(a) %i从1-&gt;a的长度，相当于for(int i=1;i&lt;=length(a);++i) for j=1:length(a)-i if a(j) &gt; a(j+1) a([1 j])=a([1 j+1]); %这样子写可以一句话交换a[j]和a[j+1]的数据，原理还不清楚 end endend 有一个4∗54*54∗5矩阵,编程求出其最大值及其所处的位置。 直接用max函数。[val idx] = max(a,[],“all”) 1234a=randi(10,[4,5])[val idx] = max(a,[],&quot;all&quot;) %val就是找到的最大值,idx是矩阵的索引(一列一列来)。%如果只有个max就只是找到每一列的最大值，返回的也不只是一个数，有多少列就有多少个最大值。%上面这样写就可以返回整个矩阵的最大值 编程求∑n=120n!\\sum_{n=1}^{20}n!∑n=120​n! 123n=1:20;y=factorial(n) %求阶乘y_sum=sum(y) %计算总和 一球从100米高度自由落下,每次落地后反跳回原高度的一半,再落下. 求它在第10次落地时,共经过多少米?第10次反弹有多高? 123456height=100s=0for i=1:10 s=s+height; height=height./2;end 有一函数f(x,y)=x2+sinxy+2yf(x,y)=x^2+sinxy+2yf(x,y)=x2+sinxy+2y,写一程序,输入自变量的值,输出函数值. 1234x=input(&quot;please input the value of x:\\n&quot;); %input函数跟python有点像y=input(&quot;please input the value of y:\\n&quot;);f=x.^2+sin(x.*y)+2.*y;fprintf(&#x27;f(x,y)=%f\\n&#x27;,f) %虽然 disp 可以用于显示数值，但在需要格式化输出的情况下，fprintf 更常用，因为它可以更灵活地处理格式说明符，并更好地适应不同类型的输出。","categories":[],"tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://xinonria.top/tags/MATLAB/"}]},{"title":"记第一次codeforces比赛(下)","slug":"记第一次codeforces比赛-下","date":"2023-10-16T13:45:18.000Z","updated":"2024-04-02T13:48:34.852Z","comments":true,"path":"posts/8b0a2c96/","permalink":"https://xinonria.top/posts/8b0a2c96/","excerpt":"","text":"D. Divide and Equalize (AC 补题) 题面 原题链接 题面大意翻译: 给定一系列数字。 可以在这列数字中取两个数aia_iai​和aja_jaj​ (i≠ji \\neq ji=j) 取aia_iai​的一个因子xxx。 将aia_iai​变成aix\\frac{a_i}{x}xai​​，把aja_jaj​变成aj⋅xa_j \\cdot xaj​⋅x。 问是否能根据任意次操作，使得最后这列数字都相等。 例如: [100,2,50,10,1] 取a3=50a_3 = 50a3​=50和a2=2a_2 = 2a2​=2，x=5x = 5x=5。将a3a_3a3​变成a3x=10\\frac{a_3}{x}=10xa3​​=10，将a2a_2a2​变成a2⋅x=10a_2 \\cdot x = 10a2​⋅x=10。此时列表变成[100,10,10,10,1]。 取a1=100a_1 = 100a1​=100和a5=1a_5 = 1a5​=1，x=10x = 10x=10。将a1a_1a1​变成a1x=10\\frac{a_1}{x}=10xa1​​=10，将a5a_5a5​变成a2⋅x=10a_2 \\cdot x = 10a2​⋅x=10。此时列表变成[10,10,10,10,10]。 在两次操作后，我们成功将这个列表的元素都变成了相同的数字。 我们只需要输出能否通过任意次操作来完成这个目标。 思路 选定一个数的一个因子，让它自身除以这个因子，让一个别的数乘以这个因子。 抽象来看，可以看作是这个数的因子转移到了另一个数身上。 所以首先第一步就是把列表里的数字都拆成质因数的乘积。 虽然可以转移任意的因子，但拆成质因数后更好判断能不能转移。 如何判断可以完成目标呢？给个例子： 这个列表[125,8,27] 拆成质因数就是$$[555, 222, 333]$$ 通过转移他们的质因数，我们可以把它变成$$[235,235,235]$$。 也就是变成了[30,30,30]。 注意到实际上就是将他们不同的质因数平均分配给nnn个元素。 所以我们可以只需要搜集质因数的个数，看最后的总个数是否是n的整数倍就可以了。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#define fi(i,l,r) for(int i=l;i&lt;=r;i++)void divided(int x, unordered_map&lt;int,int&gt;&amp; umap) //提取x的质因数并保存在哈希表里&#123; int i = 2; while (i * i &lt;= x) &#123; while (x % i == 0) &#123; umap[i]++; x /= i; &#125; i++; &#125; if (x &gt; 1) umap[x]++; //如果x自己就是质数的话就不会进入上面的循环，所以要加个特殊判断 return;&#125;void solve()&#123; int n; cin &gt;&gt; n; int a; unordered_map&lt;int, int&gt; umap; fi(i, 0, n - 1) &#123; cin &gt;&gt; a; divided(a, umap); &#125; for (auto&amp; e : umap) &#123; if (e.second % n != 0) &#123; //如果有个质因数的个数不满足是n的整数倍，那么最后就不可能完成目标 cout &lt;&lt; &quot;NO\\n&quot;; return; &#125; &#125; cout &lt;&lt; &quot;YES\\n&quot;; return;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); int t; cin &gt;&gt; t; while (t--) &#123; solve(); &#125; return 0;&#125; E. Block Sequence (AC 补题) 题面 原题链接 题目大意翻译: 给定一个列表，它需要被分成多个区块(blocks)。每个区块的第一个数字xxx表示该区块的长度，后面会跟着xxx个元素。 可以删去这个列表的任意数字，问需要至少删除几个数字才能让这个列表满足以上条件。 例如: [1,2,3,4,5] 删去1和5两个数字，列表可以被分为[[2,3,4]]。 [5,6,3,2] 删去任意数字都不能满足条件，只能全删了，回答是4。 思路 这题可以用动态规划的思路来解决。 定义dp[i]存储的是要让从i→ni \\to ni→n的序列满足条件的最小操作次数。 如果选择删去第iii个元素的话，dp[i] = dp[i+1] + 1。 如果不删的话就是dp[i] = dp[i+a[i]+1]。它作为序列头，自己自然就等于下个序列的头了。 特别的，当i+a[i]+1 &gt; n时说明必须要删掉当前的数才能满足条件。 代码 1234567891011121314151617181920212223242526272829303132void solve()&#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n), dp(n, n+1); fi(i, 0, n - 1) &#123; cin &gt;&gt; a[i]; &#125; dp[n - 1] = 1; auto getNum = [&amp;n, &amp;dp](int x) &#123; if (x &gt; n) return n + 1; if (x == n) return 0; return dp[x]; &#125;; for (int i = n - 2; i &gt;= 0; --i) &#123; dp[i] = min(dp[i + 1] + 1, getNum(i + a[i] + 1)); &#125; cout &lt;&lt; dp[0] &lt;&lt; &#x27;\\n&#x27;; return;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); int t; cin &gt;&gt; t; while (t--) &#123; solve(); &#125; return 0;&#125; F. Minimum Maximum Distance (AC 补题) 题面 原题链接 题目大意翻译： 给定一个无向无环图，上面标记了几个节点。找出一个节点到达所有节点的距离最短，输出这个节点到达最远一个标记节点的距离。 例如: 在这个图中2,6,7是标记节点，根据计算可以得出节点1或节点3到达最远标记节点的距离最小。 ①到达最远的标记节点是⑥和⑦，距离为2。 ③到达最远的标记节点是②，距离为2。 思路 我们首先从任意一个标记节点v1v_1v1​出发，找到离它最远的标记节点v2v_2v2​。 再从v2v_2v2​出发找到离它最远的标记节点v3v_3v3​(可能仍为v1v_1v1​)，记录v2v_2v2​到v3v_3v3​的距离distancedistancedistance。 最终答案就是distance2\\frac{distance}{2}2distance​。 特别的，当只有一个标记节点的时候直接返回0。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546vector&lt;vector&lt;int&gt;&gt; m; void dfs(int v, int past, vector&lt;int&gt;&amp;d)&#123; if (past != -1) d[v] = d[past] + 1; for (int&amp; u:m[v]) &#123; if(u!=past) dfs(u, v, d); &#125;&#125; void solve()&#123; int n, k; cin &gt;&gt; n &gt;&gt; k; m.assign(n, vector&lt;int&gt;(0)); vector&lt;int&gt; mark(k); fi(i, 0, k-1) &#123; cin &gt;&gt; mark[i]; --mark[i]; //它的数据从1开始，这里改成从0开始 &#125; int a, b; fi(i, 1, n - 1) &#123; cin &gt;&gt; a &gt;&gt; b; a--, b--; m[a].push_back(b); m[b].push_back(a); &#125; if (k == 1) &#123; //只有一个节点的情况 cout &lt;&lt; 0 &lt;&lt; &#x27;\\n&#x27;; return; &#125; vector&lt;int&gt; d1(n); //存的是从v1到i位置的距离 dfs(mark[0], -1, d1); int v2 = mark[0]; for (int&amp; num : mark) &#123; if (d1[v2] &lt; d1[num]) v2 = num; &#125; vector&lt;int&gt; d2(n); dfs(v2, -1, d2); int v3 = mark[0]; for (int&amp; num : mark) &#123; if (d2[v3] &lt; d2[num]) v3 = num; &#125; cout &lt;&lt; ((d2[v3] + 1) &gt;&gt; 1) &lt;&lt; &#x27;\\n&#x27;; //为什么要+1？只有+1才能过 return;&#125;","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://xinonria.top/tags/codeforces/"}]},{"title":"记第一次codeforces比赛(上)","slug":"记第一次codeforces比赛","date":"2023-10-14T15:04:57.000Z","updated":"2024-04-02T13:48:34.850Z","comments":true,"path":"posts/92111dd7/","permalink":"https://xinonria.top/posts/92111dd7/","excerpt":"","text":"写在前面 如果要提升自己算法技术的话听说刷Leetcode帮助不大，那现在每日一题转为刷codeforces上的题目吧。 第一次参加codeforces的比赛，只敢打了个div.3。2h15min只能做出两道题来，感觉自己被血虐。 赛后补了下题目，补题的时候又感觉好像也不难。。。 A. Don’t Try to Count (补题AC) 题面 原题链接 (看到这标题吓我一跳) 翻译一下题目大意： 给定两个字符串xxx和sss。 可以对xxx字符串做复制操作，就是复制自身放到后面。 例如abcabcabc复制一次变成abcabcabcabcabcabc，再复制一次变成abcabcabcabcabcabcabcabcabcabcabcabc。 问最少需要复制几次xxx，可以让sss成为xxx的一个子串。 例如： x=eforcx = eforcx=eforc s=forces = forces=force eforceforceforc复制一次变成eforceforce\\textbf{force}forceforceforc 所以只需要复制一次就可以满足条件。 思路 比赛的时候第一题没写出来蚌埠住了。主要是不知道判断复制到什么时候结束。 s字符串的最后一个字符位置乘上2？一直卡在中断条件那。 偏偏没注意到x和s的长度范围是小于25的。 在最极端的情况下x长度为1，s的长度为25。最多只需要复制五次就能达到1∗251*2^51∗25超过25了。 找子串的话可以用KMP模版，但没背。 所以直接用了C++字符串自带的find函数。 123456s = &quot;abc&quot;;x = &quot;bc&quot;;s.find(x);在s字符串里找x子串，返回x首个字符所在的位置。如果没有找到则返回string::npos。 所以最终思路就是： 边复制边查找是否存在子串，一旦找到就退出循环输出当前复制次数。 代码 头文件什么的就省略了。 123456789101112131415161718192021222324252627282930313233343536#define mem(a) memset(a,0,sizeof(a))#define dbg(x) cout&lt;&lt;#x&lt;&lt;&quot; = &quot;&lt;&lt;x&lt;&lt;endl#define fi(i,l,r) for(int i=l;i&lt;=r;i++) #define cd(a) scanf(&quot;%d&quot;,&amp;a)typedef long long ll;using namespace std; void solve()&#123; int n; int m; cin &gt;&gt; n &gt;&gt; m; string x, s; cin &gt;&gt; x &gt;&gt; s; fi(i, 0, 5) &#123; if (x.find(s) != string::npos) &#123; cout &lt;&lt; i &lt;&lt; &#x27;\\n&#x27;; return; &#125; x += x; &#125; cout &lt;&lt; &quot;-1\\n&quot;; return;&#125; int main()&#123; ios::sync_with_stdio(0); cin.tie(0); int t; cin &gt;&gt; t; while (t--) &#123; solve(); &#125; return 0;&#125; B. Three Threadlets (AC) 题面 原题链接 题面大意翻译： 给你三根木棍的长度，可以对任意一根木棍砍一刀，让它分成两半（这两半长度不能其中一个为0）。 例如666可以被分为2,42,42,4和1,51,51,5，但不能分为0,60,60,6。 最多能砍三刀，问是否能通过砍几刀，能使所有木棍最后长度相同。 例如： 1,3,2→1,2,1,2→1,1,1,1,2→1,1,1,1,1,11,3,2→1,2,1,2→1,1,1,1,2→1,1,1,1,1,11,3,2→1,2,1,2→1,1,1,1,2→1,1,1,1,1,1 可以通过砍3刀来完成任务。 6,36,126,36,126,36,12 3刀内不能让它们长度相同。 思路 我的思路有点蠢，但因为数据量小，所以能过。 由题意可知，最后这三根木棍的长度必定是小于或等于最开始的时候最短那根木棍的长度的。 所以每次以最短的那根木棍minLengthminLengthminLength为目标，把maxLengthmaxLengthmaxLength那根砍成minLength,maxLength−minLengthminLength,maxLength - minLengthminLength,maxLength−minLength这两个长度。 再把获得的新木棍加进数组里再次排序。 如果三次还不能满足条件，那么就是失败了。 看了看题解好像只用保存最小值就够了，只要用比最小值大的数去砍也行。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051bool check(vector&lt;int&gt;&amp; v) &#123; int tmp = v[0]; int len = v.size(); for (int i = 1; i != len; ++i) &#123; if (v[i] != tmp) &#123; return false; &#125; tmp = v[i]; &#125; return true;&#125; int main()&#123; int t; cin &gt;&gt; t; vector&lt;int&gt; a(3); int tmp = 0; while (t--) &#123; a.assign(3); scanf(&quot;%d %d %d&quot;, &amp;a[0], &amp;a[1], &amp;a[2]); sort(a.begin(), a.end()); if (a[0] == a[1] &amp;&amp; a[1] == a[2]) &#123; //已经都相等了就直接输出吧 cout &lt;&lt; &quot;YES&quot; &lt;&lt; &#x27;\\n&#x27;; continue; &#125; a.push_back(a[0]); a[2] -= a[0]; //砍第一刀 sort(a.begin(), a.end()); if (check(a)) &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; &#x27;\\n&#x27;; continue; &#125; a.push_back(a[0]); a[3] -= a[0]; //砍第二刀 sort(a.begin(), a.end()); if (check(a)) &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; &#x27;\\n&#x27;; continue; &#125; a.push_back(a[0]); a[4] -= a[0]; ////砍第三刀 sort(a.begin(), a.end()); if (check(a)) &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; &#x27;\\n&#x27;; continue; &#125; cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#x27;\\n&#x27;; &#125; return 0;&#125; C. Perfect Square (AC) 题面 原题链接 题目大意翻译： 给定一个n∗nn*nn∗n的矩阵，n为偶数。 要让这个矩阵顺时针旋转90°90\\degree90°后跟原来的矩阵相同。 可以对这个矩阵的字母进行改变。使a→ba \\to ba→b的代价为111，a→da \\to da→d的代价为3。当该字母为zzz时不能改变。 问如何以最小的代价，使得这个矩阵顺时针旋转90°90\\degree90°后跟原来的矩阵相同。 例如这个矩阵: abbabcbbbccbabba\\begin{matrix} &amp;a &amp;b &amp;b &amp;a \\\\ &amp;b &amp;c &amp;\\mathbf{b} &amp;b \\\\ &amp;b &amp;c &amp;c &amp;b \\\\ &amp;a &amp;b &amp;b &amp;a \\end{matrix} ​abba​bccb​bbcb​abba​ 只需要对加粗的bbb操作一次让它变成ccc就可以满足条件了。 思路 这道题有两个点。 首先是如何遍历这个矩阵。 正常我们是通过横坐标和纵坐标访问元素的，现在需要顺时针访问。 我们可以一步一步走，到达顶点处时加个判断，让它拐个弯。 真巧前几天Leetcode也有一道这种顺时针访问矩阵的题目。把当时写的lambda表达式拿过来用就可以了。 其次是如何找到需要修改的值。 可以使用双指针的办法。 例如最开始cur1cur1cur1指向(0,0)(0,0)(0,0)，cur2cur2cur2指向(0,m−1)(0, m-1)(0,m−1)。 判断cur1和cur2指向的值是否相同，不同的话就让较小的那个字母进行操作让它变成较大的那个字母。把代价存起来。 接下来cur1和cur2都往下走一步，这样依次遍历。 循环一次的话会发现有的值没有被更改，一次不行的话就再来一次，果然循环两次就可以了。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 #include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;utility&gt;#include &lt;cmath&gt; using namespace std; char a[1010][1010]; int change(char&amp; a, char&amp; b) &#123; //较小的那个字母让它变成较大的那个字母。返回代价 if (a &gt; b) swap(a, b); int res = b - a; a = b; return res;&#125; int main()&#123; int t; int n; cin &gt;&gt; t; pair&lt;int, int&gt; x, y; //用pair来存坐标 auto moveForword = [](pair&lt;int, int&gt;&amp; cur, int start, int end) &#123; //往下走一步的函数 if (cur.first == start) &#123; if (cur.second == end) cur.first += 1; else cur.second += 1; return; &#125; if (cur.second == end) &#123; if (cur.first == end) cur.second -= 1; else cur.first += 1; return; &#125; if (cur.first == end) &#123; if (cur.second == start) cur.first -= 1; else cur.second -= 1; return; &#125; if (cur.second == start) &#123; if (cur.first == start) cur.second += 1; else cur.first -= 1; return; &#125; &#125;; int cnt = 0; while (t--) &#123; cnt = 0; scanf(&quot;%d\\n&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; a[i][j] = getchar(); &#125; getchar(); &#125; for (int i = 1; i &lt;= n / 2; ++i) &#123; x.first = i, x.second = i; y.first = i, y.second = n - i + 1; for (int j = 1; j &lt;= 4 * 2; ++j) &#123; for (int w = 1; w &lt;= n - i; ++w) &#123; if (a[x.first][x.second] != a[y.first][y.second]) cnt += change(a[y.first][y.second],a[x.first][x.second]); moveForword(x, i, n - i + 1); moveForword(y, i, n - i + 1); &#125; &#125; &#125; printf(&quot;%d\\n&quot;, cnt); &#125; return 0;&#125;","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://xinonria.top/tags/codeforces/"}]},{"title":"Leetcode的第一次周赛","slug":"Leetcode的第一次周赛","date":"2023-10-10T14:05:32.000Z","updated":"2024-04-02T13:48:34.837Z","comments":true,"path":"posts/b4c96cde/","permalink":"https://xinonria.top/posts/b4c96cde/","excerpt":"","text":"前面的话 第一次参加Leetcode周赛 这次参加了周日上午十点半的第366次周赛。 在平板上打的，还没开code-server，直接用网站的在线编辑器。 开打的时候还在上着C语言理论课，不得不说这个老师还挺开明。 认为自己掌握了可以直接不来上课，让舍友帮忙签到（原话）。 如果来了就别迟到或者早退，此外在课上干什么都可以。 在这样的背景下就可以上课打lc周赛了。 对比一些老师，真的是课越水抓得越严。C语言和高数这两节课老师根本不抓，每次前排都能坐满。 比赛结果 只能做出简单的前两题。 第一题还因为写反一个变量阴沟翻船了。 题目 T1 原题链接 题面 分类求和并作差 给你两个正整数 nnn 和 mmm 。 现定义两个整数 num1num1num1 和 num2num2num2 ，如下所示： num1num1num1：范围 [1,n][1, n][1,n] 内所有 无法被 mmm 整除 的整数之和。 num2num2num2：范围 [1,n][1, n][1,n] 内所有 能够被 mmm 整除 的整数之和。 返回整数 num1−num2num1 - num2num1−num2。 分析 一眼想到的思路就是把[1,n][1,n][1,n]列出来判断奇偶相加就行了。 虽然这种太有规律的题肯定可以用数学公式推出来，但竞赛毕竟是看用时的，所以直接暴力枚举秒了。 (第一次提交的时候把sum1和sum2对应的含义弄反了，痛吃罚时5min。希望AK杯的时候不要犯这种低级错误了！) 代码 1234567891011class Solution &#123;public: int differenceOfSums(int n, int m) &#123; int num1 = 0, num2 = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (i % m == 0) num2+= i; else num1+=i; &#125; return num1 - num2; &#125;&#125;; T2 原题链接 题面 你有 nnn 颗处理器，每颗处理器都有 444 个核心。现有 n∗4n * 4n∗4 个待执行任务，每个核心只执行一个任务。 给你一个下标从 000 开始的整数数组 processorTimeprocessorTimeprocessorTime ，表示每颗处理器最早空闲时间。另给你一个下标从 000 开始的整数数组 taskstaskstasks ，表示执行每个任务所需的时间。返回所有任务都执行完毕需要的最小时间 。 注意：每个核心独立执行任务。 1234567输入：processorTime = [8,10], tasks = [2,2,3,1,8,7,4,5]输出：16解释：最优的方案是将下标为 4, 5, 6, 7 的任务分配给第一颗处理器（最早空闲时间 time = 8），下标为 0, 1, 2, 3 的任务分配给第二颗处理器（最早空闲时间 time = 10）。 第一颗处理器执行完所有任务需要花费的时间 = max(8 + 8, 8 + 7, 8 + 4, 8 + 5) = 16 。第二颗处理器执行完所有任务需要花费的时间 = max(10 + 2, 10 + 2, 10 + 3, 10 + 1) = 13 。因此，可以证明执行完所有任务需要花费的最小时间是 16 。 分析 看上去有点复杂呢，什么处理器都出来了。 分析一下样例，很容易能注意到： 要使执行任务最短，要让CPU最早空闲时间大的去匹配任务用时小的，任务用时大的要用CPU最早空闲小的。 那么可以用贪心思路解决了。 先把这两个数组排序。 一个从大到小，一个从小到大。 再每四个任务跟一个处理器匹配。 保存最长任务用时就可以了。 (lambda表达式用在sort自定义比较参数里确实方便。看上去很高级，其实目前我这个水平使用深度来说lambda真的很简单) 代码 1234567891011121314151617class Solution &#123;public: int minProcessingTime(vector&lt;int&gt;&amp; processorTime, vector&lt;int&gt;&amp; tasks) &#123; sort(processorTime.begin(),processorTime.end()); sort(tasks.begin(),tasks.end(), [](auto&amp; a, auto&amp; b) &#123;return a&gt;b;&#125;); int proMax = -1, taMax = -1; int cnt = -1; for(auto&amp; pt:processorTime) &#123; for(int i = 0; i &lt; 4; i++) &#123; taMax = max(taMax, pt+tasks[++cnt]); &#125; proMax = max(proMax, taMax); &#125; return proMax; &#125;&#125;; 最后 这次16min完成比赛（除去罚时应该是11min的呜呜），T3感觉用搜索做，T4又是二进制哈哈。 T4应该要把1都凑在一起，但每个数都统计二进制1个数会不会有点麻烦啊。 希望下次自己能完成更多的题目吧！","categories":[],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://xinonria.top/tags/Leetcode/"},{"name":"周赛","slug":"周赛","permalink":"https://xinonria.top/tags/%E5%91%A8%E8%B5%9B/"}]},{"title":"安卓平板上的VsCode","slug":"平板上的VsCode","date":"2023-10-01T02:34:10.000Z","updated":"2024-04-02T13:48:34.842Z","comments":true,"path":"posts/961970b4/","permalink":"https://xinonria.top/posts/961970b4/","excerpt":"","text":"背景 目前的笔记本是暗影精灵9，拔电后续航实在有些拉胯。 晚自习带过去两个小时，估摸只能撑一个半小时。 已经把我能想到的所有省电的办法打开了，还是这样。 搬来搬去也比较麻烦，由此萌生了用安卓平板写代码的想法。 操作 平板是小米平板6，去第三方买了键盘和笔，虽然肯定比不上原装，凑合着用。 需要软件: Termux Chrome Termux可以在安卓下模拟终端(无需root)，可以用它装个Linux，这里选择Debian。 下载 Termux f-droid下载地址 Chrome 在Google Play下载。 Termux推荐在f-droid下载，别的地方下载的会出各种奇奇怪怪的问题。 code-server官方也推荐在f-droid下载的Termux。 安装 安卓上的vscode原理是: 用Termux安装一个Linux系统 在系统里安装code-server(一个第三方软件) 启动code-server服务 使用Chrome打开本地的端口，默认为127.0.0.1:8080 第一步 Linux安装 Termux，启动！ 执行termux-setup-storage，让Termux获得访问手机空间的权限。 某个教程把storage给打错了，花了一点时间才发现问题。 更换镜像源：执行termux-change-repo，出现界面后按回车-用方向键选择Tsighua镜像-按空格选中-按回车OK。 升级软件仓库,pkg update和pkg upgrade。 我只能说只要第一次登陆这种有包管理器的系统，最好都手动升级一下，否则会有的版本太老，导致出各种问题。 4. 安装code-server 123pkg install tur-repopkg install code-servercode-server 官方说这三行命令可以直接安装，但实操下来最后启动的时候会报错。 就这个问题折磨了最久，后来发现是因为里面的某一个依赖的问题，要手动删除后重下。 但用Termux的包管理pkg也不知道node-modules在哪，所以还是按老办法来，装个Debian，在里面开code-server。 安装Debian 首先安装proot-distro pkg install proot-distro 然后安装Debian proot-distro install debian 安装完成后登陆Debian proot-distro login debian 登陆上之后老套路更新apt包管理库 apt-update &amp;&amp; apt-upgrade 第二步 code-server安装 安装code-server 根据官网，直接用脚本安装。 curl -fsSL https://code-server.dev/install.sh | sh 安装好后可以直接运行code-server试试。 我遇到了以下的问题： 在Github上code-server项目的issue找到了解决办法。 issue 感谢大佬！ 原因在于argon2这个依赖有问题，要自己删掉重下。 去code-server里找到node_modules，把里面的argon2删掉。 按照这个教程来，我自己会在安装的时候又出错。 改成用npm install argon2就行了。 安装好之后还没完。 要把默认密码给改了。 默认配置文件在这： ~/.config/code-server/config.yaml 1234bind-addr: 127.0.0.1:8080 #code-server绑定的地址和端口auth: password #验证方式，可选password或nonepassword: xxx #设置密码cert: false 保存之后就可以启动了。 第三步 code-server配置 启动！ 输入code-server 在chrome打开127.0.0.1:8080就可以正常访问了。 此时Vscode还完全没有任何配置。 插件源要手动切一下用微软vscode的插件源，要不然搜不到C++的拓展。 这里使用微软vscode的插件源，插件将更多，而且质量也更高 nano /usr/lib/code-server/lib/vscode/product.json前插入下面内容 12345678910111213&quot;extensionsGallery&quot;: &#123; &quot;serviceUrl&quot;: &quot;https://marketplace.visualstudio.com/_apis/public/gallery&quot;, &quot;cacheUrl&quot;: &quot;https://vscode.blob.core.windows.net/gallery/index&quot;, &quot;itemUrl&quot;: &quot;https://marketplace.visualstudio.com/items&quot;, &quot;controlUrl&quot;: &quot;&quot;, &quot;recommendationsUrl&quot;: &quot;&quot; &#125; 修改好之后装一下中文拓展，我自己还装了C++拓展，Python拓展。 C++拓展安装好之后还要在Debian里apt install gcc g++ gdb才能正常使用。 要用Python的话也要apt install python3，在vscode里选择好解释器。 Then all the things have done. 开始在平板上使用vscode咯！ 在平板上用vscode在Leetcode上刷题。 PS. 最近vscode的Leetcode拓展好像不能用用户名加密码正常登陆，怀疑是因为要手机号验证，但因为这个拓展没做这个界面，所以一直提示密码错误。 只能复制一下已经登录上Leetcode的Chrome上的cookie来登陆。","categories":[],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://xinonria.top/tags/vscode/"}]},{"title":"一些有用小操作","slug":"一些有用小操作","date":"2023-09-20T13:55:28.000Z","updated":"2024-04-02T13:48:34.838Z","comments":true,"path":"posts/39412549/","permalink":"https://xinonria.top/posts/39412549/","excerpt":"","text":"mid溢出 在使用二分法的时候经常会用到一行代码: 1mid = (left + right) / 2; 很正常的思维，mid就是left和right的中间值嘛。 但是当right为INT_MAX也就是int上限的时候，left+right会导致mid溢出。 如果这样写就可以避免这个溢出了。 1mid = left + ((right - left) &gt;&gt; 1); // &gt;&gt; 1 表示除以2 要养成这样写mid的习惯。 小时候看一本算法书当中依稀记得mid就是这样的，当时无知的自己还嘲笑作者喜欢装逼，又加法又减法又位运算的。 乘法取模 在计算一些大数的时候，往往题目会要求对一个较大的质数取模。 例如 (这道题每步取模就够用了) 快速幂 123456789101112#define MOD 200907long long myPow(int x, int n)&#123; long long ans = 1; while (n) &#123; if (n &amp; 1) ans = (ans * x) % MOD; //遇到1了，把当前结果乘进ans里 x = (x * x) % MOD; n &gt;&gt;= 1; //n的二进制右移一位 &#125; return ans % MOD;&#125; 但这里有一个问题，如果中途ans*x这步就直接导致溢出了怎么办？ 乘法的原理就是不断地加，我们可以用类似于快速幂的方法写一个快速乘（虽然并不快速），不过目的是保证在乘法过程中每步取模，不会出现溢出。 12345678910111213#define MOD 200907int quickAdd(int a, int b) &#123; int res = 0; while (b) &#123; if (b &amp; 1) &#123; res = (res + a) % MOD; &#125; a = (a + a) % MOD; b &gt;&gt;= 1; &#125; return res % MOD;&#125; 后续可能还会更新…","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://xinonria.top/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"C#学习之路(day4)","slug":"C-学习之路-day4","date":"2023-09-09T03:34:33.000Z","updated":"2024-04-02T13:48:34.832Z","comments":true,"path":"posts/b0dad21/","permalink":"https://xinonria.top/posts/b0dad21/","excerpt":"","text":"函数 有参数无返回值函数 使用命名参数 12345678910111213141516// **定义函数**void Foo(string name, int number, bool ok)&#123; // do something&#125;// **调用函数**// 位置参数Foo(&quot;Xinon&quot;, 18, true);// 命名参数Foo(name: &quot;Xinon&quot;, ok: true, number: 18);// 混用Foo(&quot;Xinon&quot;, ok: false,number: 18); 以上三个例子可以看出，可以使用命名参数来指定传入的值对应哪个形参。 当使用命名参数后，顺序不重要了。 但如果没有使用命名参数，就要保证位置参数的位置是正确的。 声明可选参数 为参数分配默认值后，它将变为可选参数。 如果参数中省略了可选参数，则函数执行时将使用默认值。 注意可选参数必须都放在所有必需参数之后，否则编译失败CE 123456void Foo(string name, bool ok = true, int number = 18)&#123; //do something&#125;Foo(&quot;Xinon&quot;); 若不给出可选参数的值，那么函数执行时使用默认值ok: true和number: 18。 有参数有返回值函数 简单看了一下跟C差不多就不说了。 可以看看官方文档。 Microsoft Learn链接 题外话 今天上午六点半起，七点集合，教官八点到。 有点无语。。。 天晴了拉到篮球场练习，最后评比的时候下雨了，淋着雨等所有班级过一遍动作。 过完动作天又晴了，最后留下了一身湿了的外套。 中午午睡时间挺正常，把外套晾一下应该下午就干了。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xinonria.top/tags/C/"}]},{"title":"C#学习之路(day3)","slug":"C-学习之路-day3","date":"2023-09-08T13:35:10.000Z","updated":"2024-04-02T13:48:34.831Z","comments":true,"path":"posts/444c3be6/","permalink":"https://xinonria.top/posts/444c3be6/","excerpt":"","text":"题外话 今天开始军训了，晚上也有安排，回到宿舍差不多九点半了。 少了好多时间刷题和学习。 今天的内容实际是在等教官来时用手机看的。 没有接上昨天的内容，因为不能做笔记。 本来今天内容可以把函数基本知识全写完的，命名参数啊什么的。 宿舍弄回来一个洗衣机，进水口接的水龙头炸了，只能手动加水，来来回回跑了四五趟。 明天又要六点半起床，今天就先到这里吧。 正文 函数 函数声明 void foo(); 创建一个函数声明(Microsoft Learn里叫做方法签名)。 无参数无返回值函数 1234void SayHello() &#123; // do something...&#125; 这就是函数定义，看上去跟C一样。 void表示无返回值。 int，string,double等都可与void替换，表示返回值的类型。 调用一个方法只需要直接输入就行了。 SayHello(); 貌似使用大驼峰命名法。 有参数无返回值函数 1234void SaySomething(string message)&#123; // do something...&#125; 在圆括号内指出形参的类型和名字。 按值传递和按引用传递的参数 将参数传递给某个方法时，值类型的变量会将其值复制到该方法中。 每个变量都有自己的值副本，因此不会修改原始变量。 使用引用类型时，会将值的地址传递到该方法中。 向该方法提供的变量会引用该地址中的值，因此对该变量的操作会影响另一个变量引用的值。 一个赋值进去，一个是传地址进去。 传值很常见，就是函数里随便造，离开函数还是那个值。 传地址这里给了一个样例。 1234567891011121314151617181920212223242526int[] array = &#123;1, 2, 3, 4, 5&#125;;PrintArray(array);Clear(array);PrintArray(array);void PrintArray(int[] array) &#123; foreach (int a in array) &#123; Console.Write($&quot;&#123;a&#125; &quot;); &#125;&#125;void Clear(int[] array) &#123; for (int i = 0; i &lt; array.Length; i++) &#123; array[i] = 0; &#125;&#125;------output:1 2 3 4 5 0 0 0 0 0 注意到Clear()函数中对array的操作对Array的内容发生了修改。 并不是创建了一个新数组array，把Array赋值过去，再在新数组里面把所有数设为0. 这也印证了前面说的int[]实际是一个指针。 函数内的形参能覆盖掉同名的别的函数里的参数。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xinonria.top/tags/C/"}]},{"title":"C#学习之路(day2)","slug":"C-学习之路-day2","date":"2023-09-07T07:48:48.000Z","updated":"2024-04-02T13:48:34.833Z","comments":true,"path":"posts/5d570aa7/","permalink":"https://xinonria.top/posts/5d570aa7/","excerpt":"","text":"更深入学习了数据类型的相关知识 数据范围 可使用int.MinValue和int.MaxValue来获取int类型的数据范围。 12345几种基础整型范围sbyte : -128 to 127short : -32768 to 32767int : -2147483648 to 2147483647long : -9223372036854775808 to 9223372036854775807 12345无符号整型范围byte : 0 to 255ushort : 0 to 65535uint : 0 to 4294967295ulong : 0 to 18446744073709551615 1234浮点数范围:float : -3.402823E+38 to 3.402823E+38double : -1.79769313486232E+308 to 1.79769313486232E+308decimal: -79228162514264337593543950335 to 79228162514264337593543950335 decimal会比double占用更多的内存空间，但计算小数更精准，不会出现精度丢失，适合用于金融计算等应用。 float 和 double 值在内部以二进制 (base 2) 格式存储，而 decimal 以十进制 (base 10) 格式存储。 decimal的底层实现方式后面再开个博文氵一下。 引用类型 个人理解 也就是说int[] data只是创建了一个指针？它并没有指向任何存储有数据的内存空间。 后面的new才是分配一个存储空间，并且同时让data指向这个空间。 所以如果创建了一个空引用，它是没有大小的。 Console.Write(data.Length); 会直接编译失败，因为它是空的，并不会返回0。 个人理解 实际上int[] data ={1,2,3}；也可以 可能也是系统开辟了一个存储{1,2,3}的内存空间，然后再让data指向它。 类型转换 数字转成string 12int num = 1;string str = a.ToString(); 每个数据类型都有ToString()方法。 string转成数字 Parse() 12string str = &quot;5&quot;;int num = int.Parse(first); 大部分数字数据类型都有Parse()方法。 比起Parse()更推荐使用TryParse()。 TryParse() TryParse()可同时执行多项操作 它会尝试将字符串分析成给定的数字数据类型 如果成功，它会将转换后的值存储在out参数中 它将返回bool，指示操作是成功还是失败 123456789101112131415161718192021string legalValue = &quot;520&quot;;string illegalValue = &quot;52Y&quot;;int result = 0;if (int.TryParse(legalValue, out result))&#123; Console.WriteLine($&quot;转换成功！值为&#123;result&#125;，类型为&#123;result.GetType()&#125;&quot;);&#125;else Console.WriteLine(&quot;转换失败！&quot;);if (int.TryParse(illegalValue, out result))&#123; Console.WriteLine($&quot;转换成功！值为&#123;result&#125;，类型为&#123;result.GetType()&#125;&quot;);&#125;else Console.WriteLine(&quot;转换失败！&quot;);------output:转换成功！值为520，类型为System.Int32转换失败！ Covert类 还可以使用Convert类中的方法将string转成int。 12string value1 = &quot;5&quot;;int res = Convert.ToInt32(value1); 强制类型转换 在需要转换的变量前用括号把目的类型标记一下（跟C一样）。 12double xFloat = 1.2;int xInt = (int)xFloat; 数组 排序 Array.Sort(pallets) 底层实现发现用了叫IntrospectiveSort(内省排序)的排序方法。 特点： 如果划分的大小小于16个元素，对该划分使用插入排序 如果划分的大小超过2LogN， N是数组长度，那么就使用堆排序 如果划分的大小介于两者之间，则在该划分上继续使用快速排序 避免了数据量小时用快排杀鸡用牛刀，数据量大时快排递归层数深，最坏情况时间复杂度会到O(n^2) (找个时间手搓实现一遍 12345678910111213141516string[] pallets = &#123; &quot;B14&quot;, &quot;A11&quot;, &quot;B12&quot;, &quot;A13&quot; &#125;;Console.WriteLine(&quot;已排序...&quot;);Array.Sort(pallets);foreach (var pallet in pallets)&#123; Console.WriteLine($&quot;-- &#123;pallet&#125;&quot;);&#125;------output:已排序...-- A11-- A13-- B12-- B14 反转 反转来了 Array.Reverse(pallets) 反转数组中的元素。 删除 Array.Clear(pallets, 0, 2); 表示删除从索引0开始的两个元素。 删除并不是释放内存空间，而是把这块区域标成null，此时pallets[0]仍然能正常访问。 sad，这样不是很损失性能？可能List能删除元素吧？ 调整大小 Array.Resize(ref pallets, 6); 将数组大小调整至6个元素。 此时将调过引用（使用ref关字）传入pallets数组的Resize()方法。在某些情况下，方法会要求按值（默认）或按引用（使ref关字）来传递参数。要解释此操作的必要性，需花时间详细阐释.NET中对象的管理方式。很遗憾，这超出了本模块的范围。如果有疑问，建议查看Intellisense或MicrosoftDocs，获取有关如何正确调用给定方法的示例。 呃呃，还要我自己去查ref什么意思。 传入引用？是我理解的那个C++的引用吗？","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xinonria.top/tags/C/"}]},{"title":"2至36进制的高精度加法","slug":"2至36进制的高精度加法","date":"2023-09-06T16:34:14.000Z","updated":"2024-04-02T13:48:34.825Z","comments":true,"path":"posts/28b6a9c8/","permalink":"https://xinonria.top/posts/28b6a9c8/","excerpt":"","text":"原题 今天第一次刷CodeForces，随便找了个题。 原题链接 要求实现2到36进制的累加，输出与输入进制相同。 第一行输入数字个数n 第二行输入进制。 后面n行输入累加的数字。 思考 这道题核心是实现两个数任意进制的加法。 因为带有字母，所以用string存储数字是个不错选择。 既然都用string存储了，干脆用高精度加法的思路做题吧。 假设我们要将a和b相加。 首先将a和b倒序存储，方便进位。 然后判断a和b哪个长度较短，避免越界。 每一位都转换为数字加在一起，看需不需要进位。 如果需要进位用flag标记一下。 因为加法中进位只可能进1位，所以flag可以是bool节省一点点空间。 具体见注释吧。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;string baseChar = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; //便于将数字直接转成进制的字符int base; //进制string addString(string a, string b) //高精度加法&#123; string res; int alen = a.size(), blen = b.size(); if (alen &gt; blen) swap(a, b), swap(alen, blen); //保证a长度一定小于b int i = 0; int sum; int numa, numb; bool flag = false; while (i != alen) &#123; //先一直操作直到a的末尾 //将a,b对应位上的数字或字符转成数字 numa = isalpha(a[i]) ? a[i] - &#x27;A&#x27; + 10 : a[i] - &#x27;0&#x27;; numb = isalpha(b[i]) ? b[i] - &#x27;A&#x27; + 10 : b[i] - &#x27;0&#x27;; //sum存储当前位相加结果 sum = numa + numb + flag; //进位结束了，恢复flag状态 flag = false; res.push_back(baseChar[sum % base]); //将结果存进res中 if (sum &gt;= base) &#123; //需要进位 flag = true; &#125; ++i; &#125; //把剩下b的数字加进去 while (i != blen) &#123; numb = isalpha(b[i]) ? b[i] - &#x27;A&#x27; + 10 : b[i] - &#x27;0&#x27;; //记得处理可能出现的进位 sum = numb + flag; flag = false; res.push_back(baseChar[sum % base]); if (sum &gt;= base) flag = true; ++i; &#125; //b也结束了，但还需要进一位的话就进 if (flag) res.push_back(&#x27;1&#x27;); return res;&#125;string addFunc(vector&lt;string&gt;&amp; a) //实现累加&#123; string res = a[0]; int len = a.size(); for (int i = 1; i &lt; len; i++) &#123; res = addString(res, a[i]); &#125; reverse(res.begin(), res.end()); //res是倒序的，反转一下 return res;&#125;int main()&#123; ios::sync_with_stdio(false); //关闭流同步大大提高cin效率 int w; cin &gt;&gt; w; cin &gt;&gt; base; string str; vector&lt;string&gt; a; int i = 0; while (w--) &#123; cin &gt;&gt; str; int len = str.size(); while (i &lt; len &amp;&amp; str[i] == &#x27;0&#x27;) ++i; //删去前导零 if (i) str.substr(i); i = 0; reverse(str.begin(), str.end()); //倒序存储 a.push_back(str); &#125; cout &lt;&lt; addFunc(a); return 0;&#125; 最后 感觉string在函数间拷贝来拷贝去的有点占用时间，还能继续优化一下。 不懂语言Factor是什么，最后没能提交上去，没测试能不能AC。","categories":[],"tags":[{"name":"高精度","slug":"高精度","permalink":"https://xinonria.top/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"}]},{"title":"C#学习之路(day1)","slug":"C-学习之路-day1","date":"2023-09-06T09:40:17.000Z","updated":"2024-04-02T13:48:34.829Z","comments":true,"path":"posts/767a5964/","permalink":"https://xinonria.top/posts/767a5964/","excerpt":"","text":"在Windows下使用.Net做窗口应用比较方便。所以打算开始学一学C#。 数据类型 C#有以下几种简单数据类型: 有符号整型:sbyte,short,int,long 无符号整型:byte,ushort,uint,ulong (前面的u可能是unsigned的缩写吧 Unicode字符:char (官方文档说表示UTF-16代码单元) IEEE二进制浮点:float,double (哈哈还真有跟JS一样的精度丢失bug (经典0.1 + 0.2 != 0.3)) 高精度十进制浮点数：decimal (范围比double略小，精度高，而且0.1+0.2==0.3了科科。赋值时要注意是0.1m,0.2m后面要带m,否则就是double了) 布尔值: bool C++里的auto跟C#的var对应，智能类型推断，需要初始化。 判断 跟C一样的if语句 12if (表达式) &#123;&#125;else &#123;&#125; 逻辑预算符也是&amp;&amp;,||,!。(与或非) 三元运算符也有。 a = a &gt; b? a : b; 翻译：a等于什么？来看一下，a&gt;b吗？大于的话就是a=a，否则就是a=b。 循环 while(表达式) &#123;&#125; 满足条件就循环。 do &#123;&#125;while(表达式); 先做一次看满不满足条件，满足就循环。 for(int i = 0; i &lt;= n; i++) for语句没变化 foreach(var num : nums) 这个跟C++的for(auto num : nums)一样用法，枚举列表中每个元素。 2023/9/8更正，不能对num进行赋值操作，不能修改，只能读取。 不能重新分配 num 的值，因为它是 foreach 迭代的内部实现的一部分。 控制台输出 Console.Write() 输出内容 Console.WriteLine() 输出内容，会在末尾加个换行符\\n。 PS Visual Stdio 2022对C#的intelligence code真是绝绝子，好用到翘jiojio。 按一下tab就补全了，写简单示例题的时候疯狂tab。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xinonria.top/tags/C/"}]},{"title":"支持负数的16进制转换","slug":"支持负数的16进制转换","date":"2023-09-05T02:11:33.000Z","updated":"2024-04-02T13:48:34.847Z","comments":true,"path":"posts/e739bea5/","permalink":"https://xinonria.top/posts/e739bea5/","excerpt":"","text":"原题 给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。 注意: 十六进制中所有字母(a-f)都必须是小写。 十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符’0’来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 给定的数确保在32位有符号整数范围内。 不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。 原题链接 思路 非负整数的进制转换是一道简单的循环题，取模再自除就可以完成了。 12345678910111213string toHex(int num) &#123; if (!num) return &quot;0&quot;; string res; char c; while (num) &#123; int temp = num % 16; if (temp &gt;= 10) c = char(temp - 10 + &#x27;A&#x27;); else c = char(temp + &#x27;0&#x27;); res = c + res; num /= 16; &#125; return res;&#125; 位操作 但这个代码并不支持负数的转换。 注意到题目说明 对于负整数，我们通常使用 补码运算 方法。 补码运算的相关知识见之前的文章。二进制下的负数 既然计算机中都是用二进制存储的，负数的二进制已经是补码形式了，我们就不需要考虑负数怎么转换了，跟正数二进制转十六进制一样。 那我们可以直接操纵二进制来实现进制转换。 二进制与十六进制 注意到二进制每四个数位对应十六进制的一个数位。 12BIN(1011 1100 0100)HEX(BC4) 来看二进制最前面的四位，1011的十进制表示为11，这不就跟十六进制最前面的B对上了嘛。 同理，1100十进制是12，也就是十六进制的C。 0100十进制为4，十六进制也是4。 如此方便转换，这也是为什么计算机中许多数据可以用16进制来显示（例如内存地址）。 ok,现在我们有大概的思路了。 通过位操作每次提取二进制中的四位，然后看它们对应十六进制是什么，加上就行了。 如何提取末四位呢？可以用位与操作&amp;，将要提取的数&amp; 0xf。（0xf也就是0b1111） 核心伪代码: for (i=7-&gt;0) val = (num &gt;&gt; (i * 4)) &amp; 0xf; 第一句的i从7到0，是因为题目条件保证数据范围在32位整数里，也就是有8组4位二进制。 第二句每次将num移动4的倍数位，最开始移动28位，得到的就是num最高的四位。 依次移动来获得从最高四位到末尾四位。 数据并不能占满前面几位怎么办，题目要求没有前导零。 所以要加个判断，当遇到非零数后才开始往字符串加内容。 代码 123456789101112string toHex(int num) &#123; if (!num) return &quot;0&quot;; string res = &quot;&quot;; int val; for (int i = 7; i &gt;= 0; --i) &#123; val = (num &gt;&gt; (i * 4)) &amp; 0xf; if (!val &amp;&amp; !res.size()) continue; if (val &gt;= 10) res.push_back(char(val - 10 + &#x27;a&#x27;)); else res.push_back(char(val + &#x27;0&#x27;)); &#125; return res;&#125;","categories":[],"tags":[{"name":"位操作","slug":"位操作","permalink":"https://xinonria.top/tags/%E4%BD%8D%E6%93%8D%E4%BD%9C/"}]},{"title":"快速幂","slug":"快速幂","date":"2023-09-04T03:45:54.000Z","updated":"2024-04-02T13:48:34.846Z","comments":true,"path":"posts/20c47d09/","permalink":"https://xinonria.top/posts/20c47d09/","excerpt":"","text":"昨天来大学报道了，很期待将来的学习生活。 在刷学校OJ新生题时刷到几题要用幂运算（虽然都是二次幂三次幂），正好复习一下快速幂这个算法。 朴素做法 按照定义，要多少次幂就乘以多少次数字呗。 123456long long myPow(int x, int n)&#123; long long ans = 1; for (int i = 1; i &lt;= n; ++i) ans *= n; return ans;&#125; 递归做法 很容易能发现，有些中间步骤其实我们已经计算过了，就不需要再计算了。 例如: 262^626 可以被拆成23∗232^3 * 2^323∗23，23可以拆成22∗22^3可以拆成2^2 * 223可以拆成22∗2，222^222可以拆成2∗22 * 22∗2。 这样只需要计算222^222和232^323的值是多少就行了。 不再需要乘以6下才能得到结果。 1234567long long myPow(int x, int n)&#123; if (!n) return 1; if (n &amp; 1) return myPow(x, n - 1) * x; long long temp = myPow(x, n / 2); //定义temp减少计算次数 return temp * temp;&#125; 循环做法 递归的话会占用额外的栈空间，还可以优化一下不使用递归来进行操作。 这又涉及到一点点二进制的知识了。 例如： 2102^{10}210把它的指数用二进制表示就是BIN(1010)。 所以可以把2BIN(1010)2^{BIN(1010)}2BIN(1010)变成2BIN(1000)∗2BIN(10)2^{BIN(1000)} * 2^{BIN(10)}2BIN(1000)∗2BIN(10)。 这样就可以大大节省运算次数了。 12345678910long long myPow(int x, int n)&#123; int ans = 1; while (n) &#123; if (n &amp; 1) ans *= x; //遇到1了，把当前结果乘进ans里 x *= x; n &gt;&gt;= 1; //n的二进制右移一位 &#125; return ans;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"https://xinonria.top/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"数一数二进制1个数","slug":"数一数二进制1个数","date":"2023-08-28T09:17:25.000Z","updated":"2024-04-02T13:48:34.848Z","comments":true,"path":"posts/8e7648ef/","permalink":"https://xinonria.top/posts/8e7648ef/","excerpt":"","text":"最近隔了几天没更新博客，因为最近刷的题觉得没什么价值写。 不过好在今天遇到一道题，动态规划与二进制特征结合在一起特别妙。 原题 给你一个整数 n ，对于 0 &lt;= i &lt;= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。 原题链接 思路 最简单的想法就是一个个数字数过去。 因为要多次调用数二进制1个数这个功能，所以封装一个函数用来操作。 12345678910int countEveryBits(int n)&#123; int cnt = 0; while (n) &#123; cnt += n % 2; n /= 2; &#125; return cnt;&#125; 进阶一点，我们这个函数对一个数的每个二进制位都判断一下。 有没有什么办法可以不管0，只提取其中的1呢？ Brian Kernighan 算法 Brian Kernighan 算法的原理是：对于任意整数x，令 x = x &amp; (x−1)，该运算将 x 的二进制表示的最后一个1变成0。 12345678910int countEveryBits(int n)&#123; int cnt = 0; while (n) &#123; n &amp;= (n - 1); ++cnt; &#125; return cnt;&#125; 具体原理可以读者自己手算操作一下。 这样能显著将时间复杂度降下来。 but 这样还是不够。 每个数都走一遍这个函数有点太麻烦了。 我们可以根据二进制的规则来根据前面数中1的个数来快速判断当前数1的个数吗？ 二进制特征 奇数的最后一位绝对是1。 偶数的最后一位绝对是0。 奇数中1的个数等于前一个数中1的个数+1。（因为前一个是偶数） 偶数除以2，相当于将二进制位向右移一位。 如此，我们就可以写出动态规划的规则了。 初始状态数字0中1的个数是0。 如果是奇数，那么它二进制中1的个数就是前一个数+1 如果是偶数，那么它二进制中1的个数等于它除以2对应的数中1的个数。（例如6与3中1的个数相同，8与4中1的个数相同） 代码 12345678910vector&lt;int&gt; countBits(int n) &#123; vector&lt;int&gt; res(n + 1); res[0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (i &amp; 1) res[i] = res[i - 1] + 1; //i &amp; 1（如果i是奇数就是true，反之为false） else res[i] = res[i / 2]; &#125; return res;&#125;","categories":[],"tags":[{"name":"二进制","slug":"二进制","permalink":"https://xinonria.top/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}]},{"title":"异或交换整数","slug":"异或交换整数","date":"2023-08-24T07:14:35.000Z","updated":"2024-04-02T13:48:34.845Z","comments":true,"path":"posts/b6a7a59/","permalink":"https://xinonria.top/posts/b6a7a59/","excerpt":"","text":"正常操作 正常交换两个整数我们需要创建一个临时变量。 12345int a = 1, b = 2;int temp;temp = b;b = a;a = temp; temp变量用于保存b的值，避免被覆盖，最后赋值给a。 异或操作 但通过异或操作，我们可以不需要创建额外的临时变量来交换两个整数。 异或操作见原文链接 代码 1234int a = 1, b = 2;a = a ^ b;b = a ^ b;a = a ^ b; 过程分析 第一步: a = a ^ b; 完成后a变成a ^ b（1 ^ 2）。 第二步: b = a ^ b; 此时的a存储的数据是a ^ b（1 ^ 2）。所以b就是b = (a ^ b) ^ b (b = (1 ^ 2) ^ 2)。 异或操作下，相同的数异或会变成0。根据结合律b = a ^ (b ^ b)（b = 1 ^ (2 ^ 2)）。所以会变成b = a ^ 0 (b = 1 ^ 0)。 零跟别的数异或会变成那个数。所以最后b = a(b = 1)。 这不是和正常操作一样嘛？有什么区别呢？ 注意此时我们的a存储的数据是a ^ b （1 ^ 2）。 b变量虽然被覆盖掉了，但它仍有一部分存储在a里面。 第三步: a = a ^ b 跟第二部一样，实际是a = (a ^ b) ^ b。此时括号外的这个b值为1！（a = (1 ^ 2) ^ 1）。 结合律一下。（a = (1 ^ 1) ^ 2）。 最终a = 2， b = 1。 我们成功地不使用额外变量交换了两个数！ 通过异或的操作，让b变量被覆盖后仍然留有一部分灵魂在a里。所以才能成功交换。 本文参考自CSDN","categories":[],"tags":[{"name":"位操作","slug":"位操作","permalink":"https://xinonria.top/tags/%E4%BD%8D%E6%93%8D%E4%BD%9C/"}]},{"title":"二进制下的负数","slug":"二进制下的负数","date":"2023-08-23T13:10:44.000Z","updated":"2024-04-02T13:48:34.838Z","comments":true,"path":"posts/71b459b6/","permalink":"https://xinonria.top/posts/71b459b6/","excerpt":"","text":"看上去越基础的题，背后越有大道理。 背景 日常刷Leetcode题遇到一个很基础的题目。 原题链接 给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。 进阶：你能够不使用循环/递归解决此问题吗？ 思路 正常想法就是一直mod 2和除以2判断是否是2的幂次方。 但看到这个进阶，Easy题必要达到好吗。 题目跟2的幂次方有关，计算机又是以2进制存储数据的。 这可能跟位操作有关，怎么一步到位呢？ 分析一下2的幂次方的二进制。 123DEC(2) = BIN(10)DEC(4) = BIN(100)DEC(8) = BIN(1000) 可以发现2的次幂二进制都是只有最高位是1，其他全是0的特征。 有什么办法通过位操作来直接检测这样特征的数呢？ 介绍一下补码。 补码 一般计算机使用补码来存储负整数。 我们都知道int的数据范围是[-2,147,483,647, 2,147,483,647] 正好是-231-1和231-1。 为什么要减一呢？ 因为二进制的最高位要存储符号。 如图，最高位0表示正数。 负数的最高位就是1。 既然能表达负数，那么减法可以转变为加上负数。 a - b = a + (-b) 如何保证直接转换为的负数与正数相加和正常相减一个效果呢？ 直接把最高位换成1肯定是不行的。 至少要满足一个正数加自己的负数等于0吧。 这时补码就出现了。 求负整数的补码，将其原码除符号位外的所有位取反（0变1，1变0，符号位为1不变）后加1 这样做有什么效果，我们来看看。 123456 DEX(7) = BIN(0111)//7的二进制符号位变成1 -&gt; 1111//除符号位取反 -&gt; 1000//加一 -&gt; 1001 DEX(-7) = BIN(1001) DEX(7) + DEX(-7) = BIN(0111) + BIN(1001) = 0 补码神奇吧！ 这样就可以将任意的减法操作转换为加法了。 那么这个补码对这道题来说有什么作用呢？ 思路 一个正整数&amp;(位与)自己的负数，得到最低位的1 例如 12345678910111213141516例一：DEX(12) = BIN(01100)DEX(-12) = BIN(10100)DEX(12) &amp; DEX(-12) = BIN(01100) &amp; BIN(10100) = BIN(00100)//12最低位的1在从左往右数第三个位置，所以操作后结果是100例二：DEX(56) = BIN(0111000)DEX(-56) = BIN(1001000)DEX(56) &amp; DEX(-56) = BIN(0111000) &amp; BIN(1001000) = BIN(0001000)//56最低位的1在从左往右数第四个位置，所以操作后结果是1000例三：DEX(8) = BIN(01000)DEX(-8) = BIN(11000)DEX(8) &amp; DEX(-8) = BIN(01000) &amp; BIN(11000) = BIN(01000) = DEX(8) 根据前面的分析，我们知道2的次幂二进制都是10，100，1000这样子的。 所以我们直接把它跟自己负数进行与操作，如果结果还是原来的数就说明这是2的次幂。(见例三) 代码 123bool isPowerOfTwo(int n) &#123; return n &gt; 0 &amp;&amp; (n &amp; (-n)) == n; &#125;","categories":[],"tags":[{"name":"计算机原理","slug":"计算机原理","permalink":"https://xinonria.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"}]},{"title":"C++中的哈希表","slug":"C-中的哈希表","date":"2023-08-22T10:37:11.000Z","updated":"2024-04-02T13:48:34.827Z","comments":true,"path":"posts/a381a14a/","permalink":"https://xinonria.top/posts/a381a14a/","excerpt":"","text":"最近刷题经常使用到哈希表。 哈希表 官方定义: 哈希表是根据关键码的值而直接进行访问的数据结构。 数组其实就是一张最基础的哈希表。 它的下标数字作为键(key)对应一个值(value)。 比如: a[key] = value; 键不能相同，但值可以相同。 哈希表可以用来快速检索一个元素。 比如我们拿学生的名字作为键(key)，ta所在的宿舍作为值(key)。 我们要查询一个学生在哪个宿舍，只需要， dormitory = student[name] 但是数组的下标访问本质是编程语言的一个语法糖。(详情见数组与指针) 而name大部分情况下并不是数字。 所以我们需要一个哈希函数，能够把任意信息变成一串数字。 例如: 小李 ----&gt; 0 小王 ----&gt; 1 小张 ----&gt; 2 …… 然后再直接操纵下标就能读取数据了。 12345678// 存储数据student[&quot;小李&quot;] = &quot;c1&quot;;// 读取数据cout &lt;&lt; student[&quot;小李];-----output:c1 但数字是有一定范围的，由于是从无穷集映射到有限集。 所以有可能会出现不同的键映射到同一个索引。 这就是哈希碰撞。 哈希碰撞 有两种方法解决这个问题。 拉链法 如果发生了哈希碰撞，可以将冲突的数据用链表连起来。 这样就可以通过遍历来找出冲突的值。 不过这样查找性能可能会产生损耗。 线性探测法 如果发生哈希碰撞，将冲突的数据移去空位就行了。 这样在插入数据时会产生性能损耗。 C++中的哈希表 C++的STL标准模版库中的unordered_map就是哈希表。 map是基于红黑树实现的 定义 unordered_map&lt;string, string&gt; umap; 修改 umap[key] = value 如果key不存在会创建一个。 查找 umap[key] 直接访问key对应的value值。 umap.find(key) 返回指向符合要求key的迭代器，若未找到会返回umap.end()。 umap.count(key) 返回umap中对应key值的个数，返回1或0。常用于判断哈希表内是否存在某个key。 umap.empty() 如果哈希表为空返回true，反之为false。 删除 umap.erase(key) 移除指定位置处的元素。 umap.clear() 删除所有元素。 迭代器 it-&gt;first it指向的键。 it-&gt;second it指向的值。 注意，若想根据值来反查对应的键需要遍历整个哈希表！ 小结 这篇博客当个笔记来看，以后要用到什么函数就查一下。","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xinonria.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"哈希表","slug":"哈希表","permalink":"https://xinonria.top/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"数组与指针","slug":"数组与指针","date":"2023-08-21T15:40:58.000Z","updated":"2024-04-02T13:48:34.847Z","comments":true,"path":"posts/e8ea023c/","permalink":"https://xinonria.top/posts/e8ea023c/","excerpt":"","text":"数组 我们都知道访问数组的一个元素可以通过下标访问。 例如 123456int a[5] = &#123; 1,2,3,4,5 &#125;; //初始化printf(&quot;%d %d&quot;, a[0], a[1]);-----output:1 2 通过下标我们访问了数组a的第0个和第1个元素。 但是数组的下标访问本质是编程语言的一个语法糖。 数组的本质是开辟一串连续的空间用于存储数据。 指针 数组名其实是指向数组头的一个指针。 例如： 123456int a[5] = &#123; 1,2,3,4,5 &#125;;printf(&quot;a的地址为%p，a+1地址为%p&quot;, a, a + 1); //%p输出-----output:a的地址为0000009A7DD8FD08，a+1地址为0000009A7DD8FD0C 将a+1地址0000009A7DD8FD0C与a地址0000009A7DD8FD08相减，可以得到结果为4。 根据int类型的占用空间 int类型在内存中占用了4个字节 我们可以知道a对应的是a[0]的地址，a+1对应的就是a[1]的地址。 使用*取值符(解引用操作符)，可以访问这个地址的数据。 例如: 123456int a[5] = &#123; 1,2,3,4,5 &#125;;printf(&quot;%d %d&quot;, *a, *(a+1));-----output:1 2 跟使用a[0]和a[1]访问效果一样。 通过这个例子可以看出，a[n]的本质其实就是*(a+n)。 这也解答了为什么数组是从0开始而不是从1开始。 因为数字对应了指针的偏移量。 第一个元素是头元素，偏移量为0，所以从数组是从0开始的。 最后的话 在C语言里指针是一个很重要的概念。 初学时总觉得很复杂，很麻烦，是一个难点。 学习指针时还是要多结合实际对指针的利用来学，这样才能尽快搞懂。 指针应是跟变量绑定在一起开始学的，任何一个变量都包括地址和数据。 正常赋值是对数据操作的，而指针是对地址操作的。 不知道为什么许多教程可能认为这是个难点，所以就都独立出来讲。 导致学的时候迷迷糊糊一下子就过去，也不知道什么时候派上用场。","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xinonria.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"指针","slug":"指针","permalink":"https://xinonria.top/tags/%E6%8C%87%E9%92%88/"}]},{"title":"尝试迁移博客","slug":"尝试迁移博客","date":"2023-08-20T11:55:06.000Z","updated":"2024-04-02T13:48:34.842Z","comments":true,"path":"posts/5a92151/","permalink":"https://xinonria.top/posts/5a92151/","excerpt":"","text":"主题问题 最近使用hexo的volantis主题。 好看是好看，但它的资源cdn都在unpkg上。 最近发现unpkg国内无法访问了，导致图标、图片什么的都都失效。qwq 设置了使用jsdelivr(国内能正常访问)，但似乎并不起作用。 要不换一个不依赖unpkg的主题？ 尝试了Star最高的Next主题。 但感觉实在太丑，用不下去。再加上waline评论系统时不时会出错。 还是放弃了Next。 现想寻找一又好看，支持插件又多，国内还能正常访问的主题。 正在寻找中…… 托管问题 截止到2023/8/20。该博客是托管在Github Page上的。 如图可见 广东有时能访问有时超时。可能是对Github的拦截。 放在Vercel上托管还没尝试，不过上次感觉效果挺差，比Github更慢。 CloudFlare加速怕国内更加打不开。阿里和腾讯的CDN加速都要域名备案。 听说现在备案域名限制很多，不能出现“博客”，“登陆”和社交功能。 这也太麻烦了。 那从源头解决问题，尝试把代码托管到Gitee Page上（阿里巴巴）。虽然对内容有审核，但我又不写一些违法乱纪的东西。 试试看行不行吧。 兴致勃勃转移仓库到Gitee上后发现开启Gitee Page要实名认证。 上传资料后还要等两天认证。 期待未来一切顺利。","categories":[],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://xinonria.top/tags/Blog/"}]},{"title":"检测受损word文档","slug":"检测word损坏小工具","date":"2023-08-19T13:08:40.000Z","updated":"2024-04-02T13:48:34.849Z","comments":true,"path":"posts/bae47113/","permalink":"https://xinonria.top/posts/bae47113/","excerpt":"","text":"开始 前几天使用数据恢复软件恢复了一批word文档(大概2k个)，但是有些文档已经被损坏了，完全打不开。 用word修复工具能修复吗？抱着这样的想法尝试了市面上大部分的修复工具。 结果都修复失败。 这个时候尝试看看原始数据？ 用一款开源的软件imhex 直接查看这些文档的16进制数据。 ![Alt text] 好好好，就剩个文件路径了是吧。损坏成这样只有神笔马良能修复了。 这种文件已经不可能修复了。不过剩下的几百个文件是否还有完好无损的呢？ 希望 这种文件大小还挺大，或许还有希望恢复。 但打开后还是有些乱码有些正常。 按照大小筛选一下后发现还是有几百个文档，有没有更高效的办法查看一个文档是否损坏呢？ 小知识 office里的word，ppt以及xls文件本质上都是一个zip压缩包。 它们的资源都保存在这个压缩包里。 例如这里有一个ppt幻灯片，里面有一张图片。 把它的后缀名改为.zip后解压，会得到一个这样的目录。 12345678910111213141516171819202122│ [Content_Types].xml│├─docProps│ app.xml│ core.xml│ custom.xml│ thumbnail.jpeg│├─ppt│ │ presentation.xml│ │ presProps.xml│ │ tableStyles.xml│ │ viewProps.xml│ ││ ├─media│ │ image1.jpg│ │ image2.jpg│ ││ ├─slideLayouts│ │ │ slideLayout1.xml│ │ │ slideLayout2.xml... 其中media文件夹里的image.jpg就是幻灯片插入的图片。 所以根据这个特点，通过对几个文件的观察。 会发现正常文件和损坏文件解压后的文件树都发生了变化。 其中word\\document.xml这个文件最为关键。如果这个文件不存在的话，那么就无法正常打开，可以认定为是损坏文档。 但是有的文档有word\\document.xml文件，但解压的话就会出现错误。 这时就不能单纯根据文件的有无来下判断了，还需要尝试解压一下。 工具 这种小脚本就到了Python上场了，多轮子可以直接调用。 需要的模块 os。用于读取文件。 zipfile。解压文件。 shutil。将正常文档放到一个文件夹保存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import osimport zipfileimport shutildef extract_and_copy_files(directory_path, output_folder): try: # 遍历目标文件夹中的所有文件 for file_name in os.listdir(directory_path): # 获得完整路径 file_path = os.path.join(directory_path, file_name) # 检查是否是文件 if os.path.isfile(file_path): try: # 使用zipfile模块处理压缩文件 with zipfile.ZipFile(file_path) as zip_file: # 查看压缩文档里所有的文件名 for zip_file_name in zip_file.namelist(): # 找到目标文件 if zip_file_name == &quot;word/document.xml&quot;: # 创建一个临时文件夹来解压文件 extract_folder = os.path.join(directory_path, &quot;temp&quot;) zip_file.extractall(extract_folder) extracted_file_path = os.path.join( extract_folder, zip_file_name ) if os.path.isfile(extracted_file_path): print(&quot;找到正常文档:&quot;, file_name, &quot;\\n正在复制&quot;) # 创建输出文件夹（如果不存在） if not os.path.exists(output_folder): os.makedirs(output_folder) # 复制文件到输出文件夹 output_file_path = os.path.join( output_folder, file_name ) shutil.copy2(file_path, output_file_path) # 删除临时解压文件夹 shutil.rmtree(extract_folder) except zipfile.BadZipFile: print(f&quot;&#123;file_name&#125;已损坏&quot;) except: print(f&quot;文件&#123;zip_file_name&#125;解压失败&quot;) except FileNotFoundError: print(f&quot;错误: 目录 &#x27;&#123;directory_path&#125;&#x27; 未找到&quot;) except Exception as e: print(f&quot;发生错误: &#123;e&#125;&quot;)# 指定目标文件夹和输出文件夹directory_path = &quot;...&quot;output_folder = os.path.join(directory_path, &quot;good&quot;)# 调用函数来执行操作extract_and_copy_files(directory_path, output_folder) 小结 看着控制台飞速滚动，2k个文档几秒内就全部整理完了(最后只有28个正常打开)。 如果手动一个个点开看的话不知道要多久。 感慨这种重复机械的工作还是计算机擅长。 利用自己的知识，以超高的效率解决问题，这可能就是编程的魅力所在吧。","categories":[],"tags":[{"name":"小工具","slug":"小工具","permalink":"https://xinonria.top/tags/%E5%B0%8F%E5%B7%A5%E5%85%B7/"},{"name":"python","slug":"python","permalink":"https://xinonria.top/tags/python/"}]},{"title":"快慢指针与链表","slug":"快慢指针与链表","date":"2023-08-18T11:55:35.000Z","updated":"2024-04-02T13:48:34.846Z","comments":true,"path":"posts/701ece95/","permalink":"https://xinonria.top/posts/701ece95/","excerpt":"","text":"当要求空间复杂度为O(1)，即只使用常量额外空间时，快慢指针对于处理链表中删除重复值和判断是否有环尤为重要。 快慢指针也可称为龟兔赛跑算法。 定义一个快指针，一个慢指针，它们的移动速度是不同的，根据这个速度差，我们就能完成一些工作了。 删除重复值 例题 给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。 思考 首先这个链表是有序链表。 也就是说，重复值是连续出现的。 定义两个指针，cur和i。 当发现当前节点和下个节点值相同时，即i-&gt;val == i-&gt;next-&gt;val。 i就不动了，启动cur指针。 cur一直移动到一个新的值为止。 然后再让i跟cur连上，即i-&gt;next = cur。 代码 1234567891011121314151617181920212223242526//链表定义struct ListNode &#123; int val; ListNode* next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;ListNode* deleteDuplicates(ListNode* head) &#123; if (!head) return nullptr; ListNode* i = head; //慢指针 ListNode* cur = head; //快指针 while (i) &#123; //&amp;&amp;逻辑运算符是先判断左边，如果不满足的话就不看右边直接返回false了。 if (i-&gt;next &amp;&amp; i-&gt;val == i-&gt;next-&gt;val) //防止访问出界，先判断i-&gt;next是否有值 &#123; while (cur &amp;&amp; cur-&gt;val == i-&gt;val) cur = cur-&gt;next; //防止cur访问出界，先判断cur是不是空指针了 //上面这句while循环已经把cur移动到一个新的值处了 i-&gt;next = cur; //将i-&gt;next直接连接到cur处。（没释放中间元素） &#125; i = i-&gt;next; cur = i; //正常走的话cur跟着i一起走 &#125; return head; //返回头指针，此时cur和i已经指向链表尾了 &#125; 判断是否有环 例题 给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。 如果链表中存在环 ，则返回 true 。 否则，返回 false 。 思考 本题比较符合快慢指针的本质。 利用快慢指针的速度差可以判断链表内是否有环。 首先我们知道，如果没环的话，最终是能走到空节点的。 但如果有环的话，指针会回到原来的某个位置。 我们设定快指针速度为2，即一次走两个节点。 慢指针速度为1，即一次走一个节点。 如果有环的情况下，快指针会先到达环处。 快指针会回到慢指针的背后，往前追赶。 那么最终快指针会追上慢指针，两个指针相遇。说明这个链表中有环。 代码 123456789101112bool hasCycle(ListNode* head) &#123; ListNode* fastCur = head; ListNode* slowCur = head; while (fastCur != nullptr) //快指针到达空节点说明没有环 &#123; fastCur = fastCur-&gt;next; //快指针先走 if (fastCur) fastCur = fastCur-&gt;next; //如果现在还没到尾巴的话再走一步 if (fastCur == slowCur) return true; //此时fastCur追上了slowCur，说明有环 slowCur = slowCur-&gt;next; //慢指针走一步 &#125; return false;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xinonria.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"https://xinonria.top/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"关于二叉树(下)","slug":"关于二叉树-下","date":"2023-08-17T08:55:46.000Z","updated":"2024-04-02T13:48:34.843Z","comments":true,"path":"posts/fbe9460c/","permalink":"https://xinonria.top/posts/fbe9460c/","excerpt":"","text":"二叉搜索树是有序的。 它可以完成搜索，插入以及删除等操作。 搜索 例题 思考 因为二叉搜索树有以下几个性质。 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉搜索树。 所以它的搜索效率就跟二分搜索一样很快。 使用迭代法很快就能写出来。 代码 12345678910TreeNode* searchNode(TreeNode* root, int target)&#123; while (root) &#123; if (target == root-&gt;val) return root; //找到对应值 if (target &lt; root-&gt;val) root = root-&gt;left; //目标值比当前节点小，说明目标值可能在左子树 if (target &gt; root-&gt;val) root = root-&gt;right; //目标值比当前节点大，说明目标值可能在右子树 &#125; return nullptr;&#125; 插入 例题 思考 插入就是在搜索的基础上，如果找不到这个节点，那么找个空的位置插入进去。 但在实现上，我们需要记录当前节点以及它的父节点。 否则会发现当前节点是空的之后，丢失了父节点的指针，导致无法建立起联系。 代码 12345678910111213141516171819202122TreeNode* insertNode(TreeNode* root, int num)&#123; if (!root) &#123; TreeNode* node = new TreeNode(num); return node; &#125; TreeNode* cur = root; TreeNode* parent = root; //寻找插入位置 while (cur) &#123; parent = cur; //当cur是空节点时会直接跳出循环，parent不会更新，为cur的父节点。 if (num &lt; cur-&gt;val) cur = cur-&gt;left; else cur = cur-&gt;right; &#125; //插入节点 TreeNode* node = new TreeNode(num); if (num &lt; parent-&gt;val) parent-&gt;left = node; if (num &gt; parent-&gt;val) parent-&gt;right = node; return root;&#125; 删除 例题 思考 首先要找到删除的节点，这个用前面的searchNode()函数就可以。 因为要将删除节点的子树连接回去，所以我们要找到的是匹配节点的父节点（就像插入函数那样），直接用搜索函数不行。 麻烦在于删除后结构的调整。 删除一个节点有几种情况呢？ 没找到删除节点，直接返回原来的树 找到删除节点，没有子节点，直接把他变成NULL删除 找到删除节点，有左子节点或右子节点，删去自己，把左子节点或右子节点变成根节点。 找到删除节点，同时拥有左右子节点，删去自己，左子树移到右子树的最左边左孩子上，右子节点成为根节点。 第四种情况有些难理解。 因为要保证树的有序，左子树上所有节点肯定是小于右子树任一一个节点的。 把它整个移到右子树的左叶子节点上就不会破坏有序。 代码 123456789101112131415161718192021222324252627282930313233343536TreeNode* deleteNode(TreeNode* root, int target)&#123; TreeNode* node = root; TreeNode* parent = nullptr; //寻找插入位置 while (node) &#123; if (node-&gt;val == target) break; parent = node; //当cur是空节点时会直接跳出循环，parent不会更新，为cur的父节点。 if (target &lt; node-&gt;val) node = node-&gt;left; else node = node-&gt;right; &#125; if (!node) return root; //情况一，没找到删除节点 if (!node-&gt;left &amp;&amp; !node-&gt;right) //情况二，没有左子节点和右子节点 &#123; if (parent-&gt;left-&gt;val == target) parent-&gt;left = nullptr; if (parent-&gt;right-&gt;val == target) parent-&gt;right = nullptr; return root; &#125; if (node-&gt;left &amp;&amp; node-&gt;right) //情况四，左子结点和右子节点都有 &#123; TreeNode* cur = node-&gt;right; while (cur-&gt;left) cur = cur-&gt;left; //前往右子树的最左边 cur-&gt;left = node-&gt;left; //左子树连接上右子树的最左边 if (parent-&gt;left &amp;&amp; parent-&gt;left-&gt;val == target) //删除节点是父节点的左子结点 parent-&gt;left = node-&gt;right; if (parent-&gt;right &amp;&amp; parent-&gt;right-&gt;val == target) //删除节点是父节点的右子结点 parent-&gt;right = node-&gt;right; &#125; //情况三，仅有一个子节点 if (parent-&gt;left-&gt;val == target) //删除节点是父节点的左子结点 parent-&gt;left = node-&gt;left ? node-&gt;left : node-&gt;right; //删除节点有的是左子结点还是右子节点 if (parent-&gt;right-&gt;val == target) //删除节点是父节点的右子结点 parent-&gt;right = node-&gt;left ? node-&gt;left : node-&gt;right; //删除节点有的是左子结点还是右子节点 return root;&#125; 小结 至此二叉树的一些基础操作就结束了。其他变形题都可以根据这几种基础操作的思想。 可以发现需要改变二叉树的结构往往都会复杂许多。 如构造，删除等操作。 不过在写这几篇博文的过程中也确实学到许多东西啦。对递归和指针的理解加深了许多。","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xinonria.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"https://xinonria.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"异或的妙用","slug":"异或的妙用","date":"2023-08-16T14:38:11.000Z","updated":"2024-04-02T13:48:34.845Z","comments":true,"path":"posts/8d14e5d/","permalink":"https://xinonria.top/posts/8d14e5d/","excerpt":"","text":"本来觉得这题很简单的。但看了条件之后发现还真挺难想（压根想不到位操作） 原题链接 注意条件!! 线性时间 &amp; 常量额外空间 思考 1. 暴力解法。 取一个数记为 cur ，然后从剩下的数中查找，如果找不到，则 cur 即为要找的那个数。 双层循环，时间复杂度O(n^2)。 不满足线性时间。 2. 哈希表 直接用unordered_set&lt;int, int&gt;作哈希表。 第一次遇到这个数时放进去，同时记录个数。 最后循环一遍看谁的个数是1。 然而这个解法不满足常量额外空间。 3. 排序 排序完之后看谁的值只出现一次。 使用快速排序时间复杂度O(nlogn)，还是不够快。 4. 异或 重量级登场 首先了解什么是异或。 异或运算符在C++里是^。 两个输入相同时为0，不同则为1。 a b a⊕b 0 0 0 0 1 1 1 0 1 1 1 0 我们只需要使用它这几个性质。 任何数和 0 做异或运算，结果仍然是原来的数，即 a ⊕ 0 = a。 任何数和其自身做异或运算，结果是 0，即 a ⊕ a = 0。 满足交换律和结合律 （也就是说无论一对相同的ta相隔天涯海角，中途经历了多少事情，异或都能让它们匹配在一起为0） (a1⊕a1)⊕(a2⊕a2)⊕⋯⊕(an⊕an)⊕am+1最后结果是 0⊕0⊕⋯⊕0⊕am+1=am+1 代码 1234567891011121314class Solution&#123;public: int singleNumber(vector&lt;int&gt; &amp;nums) &#123; int len = nums.size(); if (len == 1) //只有一个数就直接返回咯 return nums[0]; int ans = 0; //第一个条件:任何数和 0 做异或运算，结果仍然是原来的数 for (int num : nums) ans = ans ^ num; return ans; &#125;&#125;;","categories":[],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://xinonria.top/tags/Leetcode/"},{"name":"位操作","slug":"位操作","permalink":"https://xinonria.top/tags/%E4%BD%8D%E6%93%8D%E4%BD%9C/"}]},{"title":"关于二叉树（中）","slug":"关于二叉树(中)","date":"2023-08-16T04:12:44.000Z","updated":"2024-04-02T13:48:34.840Z","comments":true,"path":"posts/9c3fee1d/","permalink":"https://xinonria.top/posts/9c3fee1d/","excerpt":"","text":"构造 前序和中序可以唯一确定一棵二叉树。 后序和中序可以唯一确定一棵二叉树。 前序和后序不能唯一确定一棵二叉树！ 没中序遍历就无法分割了。 前序遍历&amp;中序遍历构造 分析 首先要牢记各个遍历方法的顺序。 前序遍历是：根节点-&gt;左子树-&gt;右子树 中序遍历是：左子树-&gt;根节点-&gt;右子树 所以前序遍历的第一个元素就是整个二叉树的根节点。 同理，在中序遍历中找到这个元素，它的左边就是左子树，右边就是右子树。 前序遍历的第二个元素就是根节点的左子结点。 同样它也作为一个分割点，把中序遍历分成左子树和右子树。 例如分成[1,4,2],[7,6,8] 前序遍历怎么切割呢？可以发现只需要把它分成与中序遍历数组一样长度的的两块就行了。 例如[4,1,2] (三个元素), [6,7,8] (三个元素) …… 如此循环，我们就可以用递归写出代码了。 代码 12345678910111213141516171819202122232425262728293031323334353637TreeNode* traversal(vector&lt;int&gt;&amp; preorder, int preBegin, int preEnd, vector&lt;int&gt;&amp; inorder, int inBegin, int inEnd) &#123; if (preBegin == preEnd) return nullptr; //找到当前根节点 int rootValue = preorder[preBegin]; TreeNode* node = new TreeNode(rootValue); //判断是否为叶子节点 if (preEnd - preBegin == 1) return node; //在中序遍历中找到对应节点 int divideNode; for (divideNode = 0; divideNode &lt;= inEnd; ++divideNode) if (inorder[divideNode] == rootValue) break; //左开右闭区间分割 [) //分割中序数组 int leftInorderBegin = inBegin; int leftInorderEnd = divideNode; int rightInorderBegin = divideNode + 1; int rightInorderEnd = inEnd; //分割前序数组 int leftPreorderBegin = preBegin + 1; int leftPreorderEnd = preBegin + (leftInorderEnd - leftInorderBegin) + 1; int rightPreorderBegin = leftPreorderEnd; int rightPreorderEnd = preEnd; //递归 node-&gt;left = traversal(preorder, leftPreorderBegin, leftPreorderEnd, inorder, leftInorderBegin, leftInorderEnd); node-&gt;right = traversal(preorder, rightPreorderBegin, rightPreorderEnd, inorder, rightInorderBegin, rightInorderEnd); return node; &#125; 中序遍历&amp;后序遍历构造 分析 这样子构造跟上面的前序+中序构造差别不大。 只需注意后序遍历中根节点是在最后的。 后序遍历：左子树-&gt;右子树-&gt;根节点 代码 12345678910111213141516171819202122232425262728293031323334353637TreeNode* traversal(vector&lt;int&gt;&amp; postorder, int postorderBegin, int postorderEnd, vector&lt;int&gt;&amp; inorder, int inBegin, int inEnd) &#123; if (postorderBegin == postorderEnd) return nullptr; //找到当前根节点 int rootValue = postorder[postorderEnd - 1]; TreeNode* node = new TreeNode(rootValue); //判断是否为叶子节点 if (postorderEnd - postorderBegin == 1) return node; //在中序遍历中找到对应节点 int divideNode; for (divideNode = 0; divideNode &lt;= inEnd; ++divideNode) if (inorder[divideNode] == rootValue) break; //左开右闭区间分割 [) //分割中序数组 int leftInorderBegin = inBegin; int leftInorderEnd = divideNode; int rightInorderBegin = divideNode + 1; int rightInorderEnd = inEnd; //分割后序数组 int leftpostorderBegin = postorderBegin; int leftpostorderEnd = postorderBegin + (leftInorderEnd - leftInorderBegin); int rightpostorderBegin = leftpostorderEnd; int rightpostorderEnd = postorderEnd - 1; //递归 node-&gt;left = traversal(postorder, leftpostorderBegin, leftpostorderEnd, inorder, leftInorderBegin, leftInorderEnd); node-&gt;right = traversal(postorder, rightpostorderBegin, rightpostorderEnd, inorder, rightInorderBegin, rightInorderEnd); return node; &#125; 彩蛋 画二叉树 12345678910void printTree(TreeNode* root, int level = 0, int indent = 4) &#123; if (!root) return; printTree(root-&gt;right, level + 1, indent); if (level != 0) &#123; cout &lt;&lt; setw(level * indent) &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; root-&gt;val &lt;&lt; endl; printTree(root-&gt;left, level + 1, indent);&#125; 效果 明天再做插入删除的代码吧。 未完待续…","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xinonria.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"https://xinonria.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"关于二叉树（上）","slug":"关于二叉树(上)","date":"2023-08-15T05:35:35.000Z","updated":"2024-04-02T13:48:34.838Z","comments":true,"path":"posts/a1da799a/","permalink":"https://xinonria.top/posts/a1da799a/","excerpt":"","text":"前言 最近经常刷到二叉树的题，那么好好把二叉树的相关知识点都过一下吧。 本文参考了代码随想录关于二叉树的介绍。原文链接 分类 满二叉树 一个二叉树除了叶节点外每个节点都有两个子节点，且叶节点在同一层的二叉树。就是看上去都是满的。 深度为kkk。节点数量就是2k−12^k-12k−1个。 完全二叉树 除了最底层节点没填满外，其他节点都是满的。且最底层节点必须从左到右连续！ 所以，满二叉树同时也是一个完全二叉树。 二叉搜索树 二叉搜索树是有数值且有序的。 它的子节点的位置要满足三个条件。 左子树上所有节点都小于根节点 右子树上所有节点都大于根节点 左右子树都满足二叉搜索树 如图： 以根节点10为例，左子节点6&lt;106&lt;106&lt;10，右子节点16&gt;1016&gt;1016&gt;10。 节点6同理，节点16也同理。 平衡二叉搜索树 平衡二叉搜索树也是有序树，但它跟二叉搜索树的区别在于它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 为什么要专门有个平衡二叉树呢？ 因为一个二叉搜索树极端情况下退化为链表结构，根节点在尾部或头部。这样一来搜索的效率就低了。 存储 二叉树存储有两种方式，链式存储（指针实现）和顺序存储（数组实现）。 链式存储 一般链式存储较多，例如（Leetcode默认构造的二叉树）: 12345678910struct TreeNode&#123; int val; //当前节点存放的数据 TreeNode* left; //指向左子节点 TreeNode* right; //指向右子节点 //构造函数 TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) &#123;&#125;&#125;; 顺序存储 而顺序存储则是使用下标来存储节点。 通过观察可以知道第iii个节点的左子结点下标为i∗2+1i*2+1i∗2+1，右子节点下标为i∗2+2i*2+2i∗2+2。 遍历 二叉树有四种遍历方法。 深度优先搜索 其中使用深度优先搜索的遍历方法有： 前序遍历 (中左右) 中序遍历 (左中右) 后序遍历 (左右中) (中在哪个位置就叫什么遍历，左或右不是左右子节点的意思，是左右子树的意思) 遍历可以用递归写，也可以用迭代的方法写。 由于递归底层实现也是用栈，所以可以直接用栈来代替。 如前面一篇二叉树中序遍历的实现。原文 123456789101112131415161718192021222324252627vector&lt;int&gt; inorderTraversal(TreeNode* root)&#123; stack&lt;TreeNode*&gt; s; unordered_map&lt;TreeNode*, bool&gt; umap&#123;&#123;nullptr, false&#125;&#125;; vector&lt;int&gt; res; s.push(root); TreeNode* temp; while (!s.empty()) &#123; temp = s.top(); s.pop(); if (!temp) continue; if (umap[temp]) res.push_back(temp-&gt;val); else &#123; umap[temp] = true; //由于是栈，反过来看就是左中右 s.push(temp-&gt;right); s.push(temp); s.push(temp-&gt;left); &#125; &#125; return res; &#125;&#125;; 该方法只需更改s.push()的位置就可直接实现前中后序遍历。 广度优先搜索 使用广度优先搜索实现的遍历方法为层序遍历。 使用队列来实现层序遍历。因为队列先进先出的特点可以实现广度优先搜索。 1234567891011121314151617181920vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; queue&lt;TreeNode*&gt; q; vector&lt;int&gt; res; if (root) q.push(root); int len = q.size(); while (!q.empty()) &#123; len = q.size(); for (int i = 0; i != len; ++i) //这里不能写i!=q.size()。因为len在循环体内会发生变化，会导致出错。 &#123; TreeNode* node = q.front(); q.pop(); res.push_back(node-&gt;val); if (node-&gt;left) q.push(node-&gt;left); if (node-&gt;right) q.push(node-&gt;right); &#125; &#125; return res; &#125; 未完待续…","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xinonria.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"https://xinonria.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"二叉树与递归","slug":"二叉树与递归","date":"2023-08-14T04:57:41.000Z","updated":"2024-04-02T13:48:34.844Z","comments":true,"path":"posts/17435844/","permalink":"https://xinonria.top/posts/17435844/","excerpt":"","text":"最近经常做到关于二叉树的Easy题。 二叉树的遍历总是和递归绑在一起。 如下题寻找二叉树的最大深度。 原题 原题链接 思路 用递推的思路来想，从某一个节点出发，它的最大深度就是max(左子节点最大深度，右子节点最大深度) + 1。 对于每一个节点来说都是这样的，那么就可以用递归的办法来解决了。(长度也短)，所以主要是思路问题。 代码 12345678910class Solution&#123;public: int maxDepth(TreeNode *root) &#123; if (!root) return 0; return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1; &#125;&#125;; 类似题目 原题链接 思路 既然是要求高度，那么肯定要用上刚刚的求二叉树深度的函数。比较一下左右节点最大深度绝对值&lt;=1就行了。。。。吗？ 注意看题，要求保证每个节点左右两子树高度差绝对值都不超过1。 所以直接比较左右节点只能保证根节点左右子树是平衡的。 既然直接这样写就能判断根节点了，那么是不是也可拓展到任一节点呢。 使用递归的方法就可以实现。 代码 1234567891011121314151617class Solution&#123;public: bool isBalanced(TreeNode *root) &#123; if (!root) return true; return abs(dfs(root-&gt;left) - dfs(root-&gt;right)) &lt;= 1 &amp;&amp; //判断当前节点左右子树是否平衡 isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); //递归继续判断左右子节点是否平衡 &#125; int dfs(TreeNode *root) //求当前节点向下的高度 &#123; if (!root) return 0; return max(dfs(root-&gt;left), dfs(root-&gt;right)) + 1; &#125;&#125;; 小结 递归刚学的时候（当时还在读初一）感觉有点抽象，挺难理解。 实际用起来之后发现确实挺抽象的，感觉应该这样写，然后就能正常跑起来了。 只要设置了个边界条件，它自己就可以走下去。 不过呢，缺点就是数据量大了可能会爆栈，而且不好修改递归函数里的代码，改一发动全身。 一步想错就会导致边界条件设计有问题，直接死循环。 要改的地方越来越多的时候就要回过头好好想想，递归真是这么写的吗？是不是有更好的关系来简洁地解决问题。 不过当写完后运行发现奇迹跑起来了的时候，成就感还是可以的。","categories":[],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://xinonria.top/tags/Leetcode/"},{"name":"二叉树","slug":"二叉树","permalink":"https://xinonria.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"递归","slug":"递归","permalink":"https://xinonria.top/tags/%E9%80%92%E5%BD%92/"}]},{"title":"判断相同二叉树","slug":"判断相同二叉树","date":"2023-08-13T12:22:03.000Z","updated":"2024-04-02T13:48:34.840Z","comments":true,"path":"posts/aca79b6/","permalink":"https://xinonria.top/posts/aca79b6/","excerpt":"","text":"一道较简单的Leetcode题，判断两个二叉树是否相同。 原题链接 数据范围 两棵树上的节点数目都在范围 [0, 100] 内 -104 &lt;= Node.val &lt;= 104 思路 既然要判断是否相同，那么就要遍历树的每一个节点了。 注意到数据范围节点数在100以内，不算太大。考虑用递归的方法（太大会爆栈）深度优先搜索的思路来解决。 如果两个树都能成功到达边界，那么说明这一路上都是匹配的，可以直接return true了。 如果一个到了边界另一个没到，说明这两个树绝对不是相同的，就return false 如果两个储存的值对不上的话，那么也是说明树不相同。return false 此外没到边界的话就递归下去。 代码 1234567891011121314class Solution&#123;public: bool isSameTree(TreeNode *p, TreeNode *q) &#123; if (!p &amp;&amp; !q) //两节点都到达边界 return true; if (!p || !q) //只有一个节点到达边界 （结合上个if语句想想之间的逻辑关系，为什么能这样写） return false; if (p-&gt;val != q-&gt;val) //数值不同 return false; return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right); //递归左右节点，&amp;&amp;保证左右子节点都满足条件 &#125;&#125;;","categories":[],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://xinonria.top/tags/Leetcode/"}]},{"title":"关于二叉树中序遍历","slug":"关于二叉树中序遍历","date":"2023-08-12T10:27:49.000Z","updated":"2024-04-02T13:48:34.841Z","comments":true,"path":"posts/f61fb787/","permalink":"https://xinonria.top/posts/f61fb787/","excerpt":"","text":"今天日常刷Leetcode刷到了一个二叉树中序遍历的题。原题链接 通过示例可以很明显了解到何为中序遍历，同时打算用栈结构来实现。 中序遍历 可以看作将节点投影到一个水平坐标轴上，从原点开始向右遍历。 如图顺序为:H-&gt;D-&gt;I-&gt;B-&gt;E-&gt;J-&gt;A-&gt;F-&gt;K-&gt;C-&gt;G 栈 栈遵循先进后出的原则。 把栈想象成一个桶：a1先入栈，被压在最底下；然后a2再入栈，压在a1的上面…… 如何取出里面的数据呢？拿走最上面的元素，也就是出栈。被压在最底下的元素最后才能被拿出来。 例如： 入栈顺序 = 1, 2, 3, 4 出栈顺序 = 4, 3, 2, 1 明白概念之后就到了实现这个操作了。 思路 我使用了栈结构以及访问标记来实现。每个节点都附带一个名为visited的bool值（默认false)。 先让根节点入栈（栈里面没元素怎么出栈） 然后一直循环直到栈内元素全部出来。 中途如果发现是空节点就continue回到循环开始的地方。 如果这个节点没被访问过，那么就先标记一下已被访问visited=true。 然后分别按顺序让右节点-&gt;当前节点-&gt;左节点入栈。（因为要中序遍历，所以如此入栈后出栈的顺序就是左节点-&gt;当前节点-&gt;右节点） 如果当前节点已经访问过了，那么就直接返回当前节点的值。 代码 (C++) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;unordered_map&gt;using namespace std;//二叉树定义struct TreeNode&#123; int val; TreeNode* left; TreeNode* right; TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) &#123;&#125;&#125;;class Solution&#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; s; //栈，存储每个节点的地址 unordered_map&lt;TreeNode*, bool&gt; umap&#123;&#123;nullptr, false&#125;&#125;; //visited表，判断当前节点是否访问过，初始化全为false vector&lt;int&gt; res; //答案结果 s.push(root); //根节点入栈 TreeNode* temp; //当前节点 while (!s.empty()) &#123; temp = s.top(); s.pop(); //取得栈顶的元素 if (!temp) continue; //节点为空就continue if (umap[temp]) res.push_back(temp-&gt;val); //当前节点已被访问过，返回节点的值 else &#123; umap[temp] = true; //标记已被访问 s.push(temp-&gt;right); s.push(temp); s.push(temp-&gt;left); &#125; &#125; return res; &#125;&#125;;","categories":[],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://xinonria.top/tags/Leetcode/"},{"name":"二叉树","slug":"二叉树","permalink":"https://xinonria.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"hexo配置成功","slug":"hexo配置成功","date":"2023-08-11T05:49:14.000Z","updated":"2024-04-02T13:48:34.834Z","comments":true,"path":"posts/119aaba8/","permalink":"https://xinonria.top/posts/119aaba8/","excerpt":"","text":"花了两天时间终于成功把hexo+github托管的个人博客网站做完了。 中途遇到了好多问题和障碍(哭 npm install安装时一直卡住 参考了CSDN的解决办法，发现没用。后来发现淘宝源停止对该域名解析了，遂换成官方源https://registry.npmjs.org解决问题。 虚拟服务器无法配置 白嫖了腾讯云虚拟服务器一个月。宝塔登陆不上去，1Panel安装不上。打算直接配置VanBlog。感觉可能因为网速太慢了，无法正常进入博客后台登陆。点了登陆没反应，有时候甚至加载不出来。遂放弃虚拟服务器方案，决定使用github page来托管。 hexo无法部署 运行hexo d后提示ERROR Deployer not found: git搜索后发现有个插件没装，安装后就正常了。npm install hexo-deployer-git --save 托管网站无法登陆 跟着教程用Vercel托管，但就是注册不了。Github登陆上去直接说已被封禁，邮箱注册又无法处理登录请求。发邮件给registration@vercel.com，回复已经帮我解除了，但再次登陆还是不行。感觉可能是挂了梯子的原因，又发了邮件再解除一下。关掉梯子总算登录上去了。(Gmail点验证邮件开梯子，Vercel网站不能开梯子，累死了)。然而感觉它的网站托管太慢了，还是用回Github Page了。 更换主题css不生效 这个问题折磨了最久。本地部署显示正常，但一放到线上css就不生效了。在网上找了各种办法都没用。Github上的issue隐隐感觉有用，但不知道在哪设置网址。又看到CSDN上的文章，这解决方案就离谱到家了。最后还好刷到了这篇文章，把root: /xinonria.github.io设置一下就好了。刚设置完也是不报太大希望的，吃了个饭回来发现真的成功了！ 这仅仅只是这个网站的一个开始，现在这个网站还有很多功能没有实现。图床配置，评论功能，分类系统，搜索引擎什么的还要慢慢实现。 在这过程中虽然很多时候自己都不知道怎么解决的，但也从中获得了一些经验，学到了一些东西。 Things are always difficult at the start. Just keep going.","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://xinonria.top/tags/hexo/"},{"name":"Blog","slug":"Blog","permalink":"https://xinonria.top/tags/Blog/"}]}],"categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://xinonria.top/tags/vue/"},{"name":"fastapi","slug":"fastapi","permalink":"https://xinonria.top/tags/fastapi/"},{"name":"前端","slug":"前端","permalink":"https://xinonria.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"python","slug":"python","permalink":"https://xinonria.top/tags/python/"},{"name":"machine_learning","slug":"machine-learning","permalink":"https://xinonria.top/tags/machine-learning/"},{"name":"react","slug":"react","permalink":"https://xinonria.top/tags/react/"},{"name":"前缀和","slug":"前缀和","permalink":"https://xinonria.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://xinonria.top/tags/MATLAB/"},{"name":"codeforces","slug":"codeforces","permalink":"https://xinonria.top/tags/codeforces/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://xinonria.top/tags/Leetcode/"},{"name":"周赛","slug":"周赛","permalink":"https://xinonria.top/tags/%E5%91%A8%E8%B5%9B/"},{"name":"vscode","slug":"vscode","permalink":"https://xinonria.top/tags/vscode/"},{"name":"工具","slug":"工具","permalink":"https://xinonria.top/tags/%E5%B7%A5%E5%85%B7/"},{"name":"C#","slug":"C","permalink":"https://xinonria.top/tags/C/"},{"name":"高精度","slug":"高精度","permalink":"https://xinonria.top/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"位操作","slug":"位操作","permalink":"https://xinonria.top/tags/%E4%BD%8D%E6%93%8D%E4%BD%9C/"},{"name":"数学","slug":"数学","permalink":"https://xinonria.top/tags/%E6%95%B0%E5%AD%A6/"},{"name":"二进制","slug":"二进制","permalink":"https://xinonria.top/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"计算机原理","slug":"计算机原理","permalink":"https://xinonria.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xinonria.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"哈希表","slug":"哈希表","permalink":"https://xinonria.top/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"指针","slug":"指针","permalink":"https://xinonria.top/tags/%E6%8C%87%E9%92%88/"},{"name":"Blog","slug":"Blog","permalink":"https://xinonria.top/tags/Blog/"},{"name":"小工具","slug":"小工具","permalink":"https://xinonria.top/tags/%E5%B0%8F%E5%B7%A5%E5%85%B7/"},{"name":"链表","slug":"链表","permalink":"https://xinonria.top/tags/%E9%93%BE%E8%A1%A8/"},{"name":"二叉树","slug":"二叉树","permalink":"https://xinonria.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"递归","slug":"递归","permalink":"https://xinonria.top/tags/%E9%80%92%E5%BD%92/"},{"name":"hexo","slug":"hexo","permalink":"https://xinonria.top/tags/hexo/"}]}